)
)
),
shiny::img(src = "logo/calipR_logo.png", width = "70%", height = "70%",
style = "position: relative; top: -30px; left: 30px;"),
#shiny::tags$style(".left-side, .main-sidebar {padding-top: 180px}"),
shinydashboard::sidebarMenu(id = "sidebarid",
shinydashboard::menuItem(
"Description", tabName = "des"),
shinydashboard::menuItem(
"Tutorial", tabName = "tuto"),
shinydashboard::menuItem(
"Analyze Your Data", tabName = "ana"),
shinydashboard::menuSubItem("Prepare Data", tabName = "prep"),
shinydashboard::menuSubItem("Visualize Raw Data", tabName = "viz"),
shinydashboard::menuSubItem("Optimize Analysis Parameters", tabName = "opt"),
shinydashboard::menuSubItem("Analyze data", tabName = "ana_full"),
shinydashboard::menuSubItem("Visualize Results", tabName = "viz_res"),
shiny::conditionalPanel( 'input.sidebarid == "prep"',
shiny::selectInput("stim_num", label ="Stimuli number (/cell)", c("1" = "1", "2" = "2", "3" = "3",
"4" = "4", "5" = "5", "6"="6", "7"="7",
"8"="8", "9"="9","10"="10")),
shiny::textInput("folder", label = NULL, placeholder = "Write folder's name (where all the files are)"),
shiny::actionButton("launch", "Load & Tidy Data", align = "center")),
shiny::conditionalPanel( 'input.sidebarid == "viz"',
),
shiny::conditionalPanel( 'input.sidebarid == "ana_full"',
shiny::textInput("peak_thresh_full", label = "Peak Threshold", placeholder = "Peak Threshold"),
shiny::textInput("rise_full", label = "Borders Range", placeholder = "Frame before peak"),
shiny::textInput("lambda_full", label = "Lambda"),
shiny::textInput("gam_full", label = "gam"),
shiny::checkboxInput("false_pos_full", label = "False Positives Estimation"),
shiny::checkboxInput("groups", label = "Compare groups"),
shiny::actionButton("ana_full_button", "Launch Full Analysis", align = "center"))
)),
shinydashboard::dashboardBody(
shiny::tags$head(shiny::tags$style(shiny::HTML("
/* main sidebar */
.skin-blue .main-sidebar {
background-color: #172330;
}
/* active selected tab in the sidebarmenu */
.skin-blue .main-sidebar .sidebar .sidebar-menu .active a{
background-color: #5499c7
}
"))),
shinydashboard::tabItems(
shinydashboard::tabItem("des",
shiny::fluidRow(
shiny::img(src = "logo/calipR_logo.png",
style = "border: 1px;
color: white;
position: absolute;
top : 100px;
left: 300px;
right: 0;
margin: 0 auto;
max-width: 250px;"), shiny::div(style = "height:1000px;")),
shiny::fluidRow(
shiny::HTML( "<center> <p style = 'font-size: 20px; word-wrap: break-word;
width: 1000px; align: justify; color: black; padding-top: 50px;
position: absolute;
top: 400px;
left: 250px;
right: 0;
margin: 0 auto;
max-width: 600px;'> <b> calipR </b> is an open source software designed to facilitate calcium imaging data analysis.
It is fully written in the R programming language.
With this Graphical User Interface (GUI) you can analyze your data
without any programming skills.<br> <br>
Two workflows are available: one that allows you to automatize
ROIs detection with the Trackmate imageJ plugin and another
one that takes the output from manual ROI detection in ImageJ.
To start with your first analysis you can go on to the Tutorial page.</p> </center>"),
),
shiny::fluidRow(shiny::tags$br()),
shiny::fluidRow(shiny::tags$br()),
shiny::fluidRow(shiny::tags$br()),
),
shinydashboard::tabItem("ana", shiny::fluidRow(shiny::div(style = "height:1000px;"))),
shinydashboard::tabItem("tuto", shiny::fluidRow(shiny::div(style = "height:1000px;"))),
shinydashboard::tabItem("prep",
shiny::tags$style(shiny::HTML("
.box.box-solid.box-primary>.box-header {
color:#fff;
background:#5499c7
}
.box.box-solid.box-primary{
border-bottom-color:#5499c7  ;
border-left-color:#5499c7  ;
border-right-color:#5499c7  ;
border-top-color:#5499c7  ;
}
.box.box-primary>.box-header {
color:#000000;
background:#fff
}
.box.box-primary{
border-bottom-color:#5499c7  ;
border-left-color:#5499c7  ;
border-right-color:#5499c7  ;
border-top-color:#5499c7  ;
}
")),
shiny::fluidRow(class = "myRow1",
shiny::column(12,
shinydashboard::box(title = "Dataset Prepared", width = 12, solidHeader = TRUE, status = "primary", collapsible = T,
DT::dataTableOutput("df_sql")),
shiny::div(style = "height:1000px;")))),
shinydashboard::tabItem("viz",
shiny::fluidRow(
shinydashboard::box(title = "Plotting Cells", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("cell", label = NULL, placeholder = "Enter the name of the cell you want to plot"),
shiny::actionButton("cell_click", "Plot Cell", align = "center"),
shiny::plotOutput(outputId = "plot_cell")), shiny::div(style = "height:1000px"))),
shinydashboard::tabItem("opt",
shiny::fluidRow(
shinydashboard::box(title = "Optimize Parameters", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("peak_thresh", label = "Peak Threshold", placeholder = "Enter the peak threshold you want to try (z score)"),
shiny::textInput("rise_range", label = "Range", placeholder = "Enter the range taken to find a peak start (integer between 5 and 60)"),
shiny::textInput("lambda", label = "Lambda", placeholder = "Enter the Lambda parameter for the Deconvolution (integer)"),
shiny::textInput("gam", label = "Gam", placeholder = "Enter the Gam parameter for the Deconvolution (double between 0-1)"),
shiny::textInput("n_cells", label = "Number of cells", placeholder = "Enter the number of cells you want to run the stimulation on"),
shiny::checkboxInput("false_pos", label = "Estimate False Positives"),
shiny::checkboxInput("show_peak", label = "Show Peaks"),
shiny::uiOutput('responders'),
shiny::uiOutput('non_responders'),
shiny::actionButton("sim", "Simulate Analysis", align = "center"),
shiny::actionButton("plot_responders", "Plot Responder", align = "center"),
shiny::actionButton("plot_non_responders", "Plot Non Responder", align = "center")),
shinydashboard::box(title = "Try other parameters on a given cell", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("cell_opt", label = "Cell", placeholder = "On which cell do you want to try new parameters ?"),
shiny::textInput("peak_thresh_bis", label = "Threshold", placeholder = "Enter the peak threshold you want to try (z score)"),
shiny::textInput("rise_range_bis", label = "Range", placeholder = "Enter the range taken to find a peak start (integer between 5 and 60)"),
shiny::textInput("lambda_bis", label = "Lambda", placeholder = "Enter the Lambda parameter for the Deconvolution (integer)"),
shiny::textInput("gam_bis", label = "Gam", placeholder = "Enter the Gam parameter for the Deconvolution (double between 0-1)"),
shiny::checkboxInput("false_pos_bis", label = "Estimate False Positives"),
shiny::checkboxInput("show_peak_bis", label = "Show Peaks"),
shiny::actionButton("sim_bis", "Simulate Analysis", align = "center"),
shiny::actionButton("plot_simulation_bis", "Plot Cell", align = "center"))),
shiny::fluidRow(
shinydashboard::box(title = "Plot Window", width = 6, solidHeader = TRUE, status = "primary",
shiny::plotOutput(outputId = "plot_cell_sim")),
shinydashboard::box(title = "Plot Window", width = 6, solidHeader = TRUE, status = "primary",
shiny::plotOutput(outputId = "plot_cell_sim_bis"))),
shiny::fluidRow(
shinydashboard::box(title = "Statistics", width = 6, solidHeader = TRUE, status = "primary",
DT::dataTableOutput("stats_opt")))),
shinydashboard::tabItem("ana_full",
shiny::fluidRow(
shinydashboard::box(title = "Description of Responses", width = 12, solidHeader = TRUE, status = "primary",
shinycssloaders::withSpinner(DT::dataTableOutput("resp_count"), type = 6),
DT::dataTableOutput("resp_group_stim"),
DT::dataTableOutput("peaks_by_class"),
DT::dataTableOutput("overall_q"),
DT::dataTableOutput("post_hoc_mcnemar")
)),
shiny::fluidRow(
shinydashboard::box(title = "Dual Proportions", width = 12, solidHeader = TRUE, status = "primary",
shiny::uiOutput("stim_list_1"),
shiny::uiOutput("stim_list_2"),
shiny::actionButton("dual_button", "Compute Dual Proportions", align = "center" ),
shiny::br(),
shiny::br(),
DT::dataTableOutput("dual_prop")),shiny::div(style = "height:1000px;"))),
shinydashboard::tabItem("viz_res",
shiny::fluidRow(
shinydashboard::box(title = "Plotting Cells", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("cell_bis", label = NULL, placeholder = "Enter the name of the cell you want to plot"),
shiny::actionButton("cell_click_bis", "Plot Cell", align = "center"),
shiny::plotOutput(outputId = "plot_cell_bis")),shiny::div(style = "height:1000px;")))
)))
server <- function(input, output){
sqlitePath <- getwd()
folder <- shiny::reactive({
if(is.null(input$folder)) {return()}
else{
folder <- input$folder
folder
}
})
stim_numb <- shiny::reactive({
if(is.null(input$stim_num)) {return()}
else{
stim_numb <- as.numeric(input$stim_num)
stim_numb
}
})
df_final <- shiny::eventReactive(input$launch, {
df <- calipR::prepareData(folder(), stim_numb(), 0.25, compare_groups = TRUE)
calipR::saveData(df, "db_cq.sqlite", "df_full")
df
})
output$df_sql <- DT::renderDataTable({
if(is.null(df_final())) {return()}
else{
df <- calipR::loading100("db_cq.sqlite", "df_full")
df <- DT::datatable(df)
df
}
})
df_plot <- shiny::eventReactive(input$cell_click, {
df <- calipR::get_cell(input$cell, "db_cq.sqlite", "df_full")
df
})
output$plot_cell <- shiny::renderPlot({
p <- calipR::cell_plot_shiny(df_plot())
p
})
res_sim <- shiny::reactiveValues(res = NULL)
shiny::observeEvent(input$sim, {
print("Simulation started")
df_sub <- calipR::get_sub_df("db_cq.sqlite", "df_full", input$n_cells)
res_sim$res <- calipR::downstream_analysis(df_sub, threshold = input$peak_thresh,
borders_range = input$rise_range, lambda = input$lambda, gam = input$gam,
false_pos = input$false_pos)
})
if(is.null(res_sim)){
}
else{
output$responders <- shiny::renderUI({
data <- res_sim$res
responders <- unique(data[[1]]$Cell_id)
shiny::selectInput(inputId = "responders", "Responders", responders)
})
}
if(is.null(res_sim)){
}
else{
output$non_responders <- shiny::renderUI({
data <- res_sim$res
cells <- unique(data[[2]]$Cell_id)
responders <- unique(data[[1]]$Cell_id)
non_responders <- cells %in% responders
non_responders <- unlist(purrr::map2(cells, non_responders, function(x,y) if(y == FALSE){x}))
shiny::selectInput(inputId = "non_responders", "Non Responders", non_responders)
})
}
if(is.null(res_sim)){
}
else{
output$stats_opt <- DT::renderDataTable({
data <- res_sim$res
res2 <- data[[3]][[2]]
res2
})
}
shiny::observeEvent(input$plot_responders, {
data <- res_sim$res
output$plot_cell_sim <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$responders, line = "gam", show_peak = input$show_peak)
p
})
})
shiny::observeEvent(input$plot_non_responders, {
data <- res_sim$res
output$plot_cell_sim <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$non_responders,
line = "gam", show_peak = input$show_peak)
p
})
})
shiny::observeEvent(input$sim_bis, {
print("second stim started")
df <- res_sim$res[[2]]
print("df ok ")
df_sub_bis <- df[df$Cell_id == input$cell_opt]
print("df_sub ok")
res_sim$res_bis <- calipR::downstream_analysis(df_sub_bis, threshold = input$peak_thresh_bis,
borders_range = input$rise_range_bis, lambda = input$lambda_bis,
gam = input$gam_bis, false_pos = input$false_pos_bis, one_cell = TRUE)
})
shiny::observeEvent(input$plot_simulation_bis, {
data <- res_sim$res_bis
output$plot_cell_sim_bis <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$cell_opt, line = "gam", show_peak = input$show_peak_bis)
p
})
})
### Analyze the full dataset
# This block makes the check box "compare groups" reactive
shiny::observe({
group_value <- input$groups
shiny::updateCheckboxInput(shiny::getDefaultReactiveDomain(), "groups", value = group_value)
})
### This block codes alows to launch the analysis when the button analyze dataset is clicked on. It runs the whole analysis, on the whole dataset
res <- shiny::eventReactive(input$ana_full_button, {
df_full <- calipR::get_full_df("db_cq.sqlite", "df_full")
res <- calipR::downstream_analysis(df_full, threshold = input$peak_thresh_full,
borders_range = input$rise_full, lambda = input$lambda_full, gam = input$gam_full,
false_pos = input$false_pos_full, compare_groups = input$groups)
# Extracting and saving the data table containing one row for each peak with the informations
#about the peak
res1 <- res[[1]]
calipR::saveData(res1, "db_cq.sqlite", "peak_res")
# Extracting and saving the full data table updated
res2 <- res[[2]]
calipR::saveData(res2, "db_cq.sqlite", "df_final")
res
})
output$resp_count <- DT::renderDataTable({
res <- res()
res1 <- res[[3]][[1]]
DT::datatable({res1},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
})
output$resp_group_stim <- DT::renderDataTable({
res <- res()
res2 <- res[[3]][[2]]
DT::datatable({res2},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
})
output$overall_q <- DT::renderDataTable({
res <- res()
if(is.character(res[[3]][[3]][[1]])) {
}
else{
res3 <- res[[3]][[3]][[1]]
DT::datatable({res3},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
}
}
)
output$post_hoc_mcnemar <- DT::renderDataTable({
res <- res()
if(is.character(res[[3]][[3]][[1]])) {
}
else{
res4 <- res[[3]][[3]][[2]]
DT::datatable({res4},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
}
})
### Computing dual proportions (proportion of cells responding to one stimulus that also responds to another stimulus)
output$stim_list_1 <- shiny::renderUI({
res <- get_full_df("db_cq.sqlite", "peak_res")
stim_list <- unique(res$Start_peak_stimulus)
shiny::selectInput(inputId = "stim_list_1", "Stimulus 1", stim_list)
})
output$stim_list_2 <- shiny::renderUI({
res <- get_full_df("db_cq.sqlite", "peak_res")
stim_list <- unique(res$Start_peak_stimulus)
shiny::selectInput(inputId = "stim_list_2", "Stimulus 2", stim_list)
})
t <- shiny::eventReactive(input$dual_button, {
res <- get_full_df("db_cq.sqlite", "peak_res")
t <- dual_prop(res, input$stim_list_1, input$stim_list_2)
})
output$dual_prop <- DT::renderDataTable(
DT::datatable({t()},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
))
### Ajouter des visualisations des pourcentages par groupe, par coverslip etc. :
#output$viz <-  if(peak_res calipR::get_full_df("db_cq.sqlite", "peak_res")
}
shiny::shinyApp(ui, server)
}
launch_GuiGui()
#' Analyze_Responses
#'
#' @param data
#' @param df_clean
#' @param compare_groups
#'
#' @return
#' @export
#'
#' @examples
Analyze_Responses <- function(data, df_clean, compare_groups = FALSE, one_cell = FALSE){
### Adding a variable "Response" for each stimulus in df_clean
if(compare_groups == FALSE){
d <- unique(df_clean[,c("Cell_id", "stimulus")])
d_list <- split(d,cumsum(1:nrow(d) %in% seq(1:nrow(d))))
d_list <- lapply(d_list, function(x) data.table::setDT(x)[, Response := ifelse(is.na(
data[data$Cell_id == x$Cell_id &
data$Start_peak_stimulus == x$stimulus,]$Cell_id[1]),
FALSE, TRUE) ])
d <- do.call(rbind, d_list)
stim_list <- unique(d$stimulus)
n_cells <- length(unique(d$Cell_id))
n_responders <- length(unique(d[d$Response == TRUE]$Cell_id))
prop_total <- n_responders / n_cells
stats <- data.table::setDT(list("n_cells" = n_cells, "n_responders" = n_responders, "Proportion" = prop_total))
n_responses_by_stim <- unlist(lapply(stim_list, function(x) sum(d$stimulus == x & d$Response == TRUE)))
prop_by_stim <- n_responses_by_stim / n_cells
prop_by_stim_responders <- n_responses_by_stim / n_responders
df_final <- data.frame(Stimulus = stim_list)
df_final$Resp <- n_responses_by_stim
df_final$Proportion_of_responders <- prop_by_stim_responders
df_final$Proportion_of_total_cells <- prop_by_stim
d$Response <- ifelse(d$Response == TRUE, 1,0)
if(one_cell == FALSE){
res <- Compare_props(d)
}
if(one_cell == TRUE){
res = NULL
}
### Peak description by stimulus :
if(length(data$Cell_id) != 0){
data <- data[, peak_duration := End_peak_frame - Start_peak_frame]
}
}
if(compare_groups == TRUE) {
d <- unique(df_clean[,c("Cell_id", "stimulus", "group")])
d_list <- split(d,cumsum(1:nrow(d) %in% seq(1:nrow(d))))
d_list <- lapply(d_list, function(x) data.table::setDT(x)[, Response := ifelse(is.na(
data[data$Cell_id == x$Cell_id &
data$Start_peak_stimulus == x$stimulus &
data$group == x$group,]$Cell_id[1]),
FALSE, TRUE)])
d <- do.call(rbind, d_list)
stim_list <- unique(data$Start_peak_stimulus)
group_list <- unique(d$group)
n_cells <- length(unique(d$Cell_id))
n_cells_by_group <- lapply(group_list, function(x) as.character(dim(d[d$group == x, .(unique(Cell_id))])[1]))
dt_cells <- data.table::setDT(n_cells_by_group)
colnames(dt_cells) <- group_list
n_responders <- length(unique(d[d$Response == TRUE]$Cell_id))
# Réponses par groupe :
n_responses_by_group <- lapply(group_list, function(x) as.character(sum(d$group == x & d$Response == TRUE)))
dt_resp <- data.table::setDT(n_responses_by_group)
colnames(dt_resp) <- group_list
prop_by_group <- as.character(as.numeric(n_responses_by_group) / as.numeric(unlist(n_cells_by_group)))
dt_prop <- data.table::setDT(lapply(prop_by_group, function(x) x))
colnames(dt_prop) <- group_list
resp_by_group_and_stim <- unlist(lapply(group_list, function(x) lapply(stim_list, function(y) sum(d$group == x & d$stimulus == y & d$Response == TRUE))))
prop_by_group_and_stim_responders <- resp_by_group_and_stim / rep(unlist(as.numeric(n_responses_by_group)), each = length(stim_list))
prop_by_group_and_stim <- resp_by_group_and_stim / rep(unlist(as.numeric(n_cells_by_group)), each = length(stim_list))
stats <- rbindlist(list(dt_cells,dt_resp,dt_prop))
stats$Variable <- c("n_cells", "n_responders", "Proportion")
df_final <- data.frame(Stimulus = rep(stim_list, times = length(group_list)))
df_final$group <- rep(group_list, each = length(stim_list))
df_final$resp <- resp_by_group_and_stim
df_final$prop_responders <- prop_by_group_and_stim_responders
df_final$prop_total_cells <- prop_by_group_and_stim
df_final <- df_final[df_final$resp != 0, ]
#res <- glmer(Response ~ group * stimulus + (1|Cell_id), family = binomial, data = d)
res <- "NO STATS"
}
print("Analyze Responses OK")
#return(list(data_count, data_count_stim[[2]], between_stim[[1]], between_stim[[2]]))
return(list(stats, df_final, res))
}
#' Compare_props
#'
#' @param data the full output from Count_responders_stim()
#'
#' @return a list with 2 elements. The first is the general summary of the cochran's q test
#' the second is the results of the pairwise comparisons between stimuli with McNemar test with correction for multiple comparisons
#' @export
#'
#' @examples
Compare_props <- function(data){
res_tot <- rstatix::cochran_qtest(data, Response~stimulus|Cell_id)
res_post_hoc <- rstatix::pairwise_mcnemar_test(data, Response~stimulus|Cell_id)
return(list(res_tot, res_post_hoc))
}
launch_GuiGui()
library(calipR)
launch_GuiGui()
library(calipR)
library(calipR)
launch_GuiGui()
