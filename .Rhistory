false_pos = input$false_pos, simulation = TRUE)
})
if(is.null(res_sim)){
}
else{
output$responders <- shiny::renderUI({
data <- res_sim$res
responders <- unique(data[[1]]$Cell_id)
shiny::selectInput(inputId = "responders", "Responders", responders)
})
}
if(is.null(res_sim)){
}
else{
output$non_responders <- shiny::renderUI({
data <- res_sim$res
cells <- unique(data[[2]]$Cell_id)
responders <- unique(data[[1]]$Cell_id)
non_responders <- cells %in% responders
non_responders <- unlist(purrr::map2(cells, non_responders, function(x,y) if(y == FALSE){x}))
shiny::selectInput(inputId = "non_responders", "Non Responders", non_responders)
})
}
if(is.null(res_sim)){
}
else{
output$stats_opt <- DT::renderDataTable({
data <- res_sim$res
res2 <- data[[3]][[2]]
res2
})
}
shiny::observeEvent(input$plot_responders, {
data <- res_sim$res
output$plot_cell_sim <- shiny::renderPlot({
print(data[[1]])
print(data[[2]])
p <- cell_plot(data[[2]], data[[1]], var = input$cell_plot_var, cell = input$responders, line = "gam", show_peak = input$show_peak)
p
})
})
shiny::observeEvent(input$plot_non_responders, {
data <- res_sim$res
output$plot_cell_sim <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = input$cell_plot_var, cell = input$non_responders,
line = "gam", show_peak = input$show_peak)
p
})
})
shiny::observeEvent(input$sim_bis, {
print("second stim started")
df <- res_sim$res[[2]]
print("df ok ")
df_sub_bis <- df[df$Cell_id == input$cell_opt]
print("df_sub ok")
res_sim$res_bis <- downstream_analysis(df_sub_bis, threshold = input$peak_thresh_bis,
borders_range = input$rise_range_bis, lambda = input$lambda_bis,
gam = input$gam_bis, false_pos = input$false_pos_bis, one_cell = TRUE)
})
shiny::observeEvent(input$plot_simulation_bis, {
data <- res_sim$res_bis
output$plot_cell_sim_bis <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$cell_opt, line = "gam", show_peak = input$show_peak_bis)
p
})
})
### Analyze the full dataset
# This block makes the check box "compare groups" reactive
shiny::observe({
group_value <- input$groups
shiny::updateCheckboxInput(shiny::getDefaultReactiveDomain(), "groups", value = group_value)
})
### This block codes alows to launch the analysis when the button analyze dataset is clicked on. It runs the whole analysis, on the whole dataset
res <- shiny::observeEvent(input$ana_full_button, {
print("inside anafull")
df_full <- calipR::get_full_df("db_cq.sqlite", "df_full")
print("df_full ok")
print("input$groups")
print(input$groups)
res_f <- downstream_analysis(df_full, threshold = input$peak_thresh_full,
borders_range = input$rise_full, lambda = input$lambda_full, gam = input$gam_full,
false_pos = input$false_pos_full, compare_groups = input$groups)
# Extracting and saving the data table containing one row for each peak with the informations
#about the peak
res1 <- res_f[[1]]
print(res1)
print(str(res1))
calipR::saveData(res1, "db_cq.sqlite", "peak_res")
# Extracting and saving the full data table updated
res2 <- res_f[[2]]
print(res2)
print(str(res2))
calipR::saveData(res2, "db_cq.sqlite", "df_final")
res3_1 <- data.table::setDT(res[[3]][[1]])
print(res3_1)
print(str(res3_1))
calipR::saveData(res3_1, "db_cq.sqlite", "stats_desc_final")
if(input$groups == TRUE){print( "it is true")}
else{
print("it is not true")
res3_3_1 <- data.table::setDT(res[[3]][[2]][[1]])
calipR::saveData(res3_3_1, "db_cq.sqlite", "overall_q")
res3_3_2 <- data.table::setDT(res[[3]][[2]][[2]])
calipR::saveData(res3_3_2, "db_cq.sqlite", "pairwise")
}
res_f
})
# retrieving full dataset and peaks dataset :
if(dim(calipR::checkTable("db_cq.sqlite", "'df_final'"))[1] == 0) {
}
else{
full <- calipR::get_full_df("db_cq.sqlite", "df_final")
peaks <- calipR::get_full_df("db_cq.sqlite", "peak_res")
}
res <- shiny::eventReactive(input$update_button,{
if(input$base_resp == TRUE){
peaks_wo_base <- calipR::base_resp.rm(peaks, full)[[1]]
full_wo_base <- calipR::base_resp.rm(peaks, full)[[2]]
res <- Analyze_Responses(peaks_wo_base, full_wo_base, var_list = input$grouping_var)
}
else{
res <- Analyze_Responses(peaks, full, var_list = input$grouping_var)
}
print(res)
res
})
observeEvent(input$update_button, {
output$resp_count <- DT::renderDataTable({
if(dim(calipR::checkTable("db_cq.sqlite", "'stats_desc_final'"))[1] == 0) {}
else{
DT::datatable({res()[[1]]},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
pageLength = 100,
c("copy", "csv")),
class = "display"
)
}
})
output$overall_q <- DT::renderDataTable({
# if(dim(calipR::checkTable("db_cq.sqlite", "'overall_q'"))[1] == 0) {}
# else{
DT::datatable({res()[[2]][[1]]},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
#}
}
)
output$post_hoc_mcnemar <- DT::renderDataTable({
#        if(dim(calipR::checkTable("db_cq.sqlite", "'pairwise'"))[1] == 0) {}
#else{
DT::datatable({res()[[2]][[2]]},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
# }
})
### Computing dual proportions (proportion of cells responding to one stimulus that also responds to another stimulus)
output$stim_list_1 <- shiny::renderUI({
if(dim(calipR::checkTable("db_cq.sqlite", "'peak_res'"))[1] == 0) {}
else{
e <- calipR::get_full_df("db_cq.sqlite", "peak_res")
stim_list <- unique(e$Start_peak_stimulus)
shiny::selectInput(inputId = "stim_list_1", "Stimulus 1", stim_list)
}
})
output$stim_list_2 <- shiny::renderUI({
if(dim(calipR::checkTable("db_cq.sqlite", "'peak_res'"))[1] == 0) {}
else{
f <- calipR::get_full_df("db_cq.sqlite", "peak_res")
stim_list <- unique(f$Start_peak_stimulus)
shiny::selectInput(inputId = "stim_list_2", "Stimulus 2", stim_list)
}
})
t <- shiny::eventReactive(input$dual_button, {
if(dim(calipR::checkTable("db_cq.sqlite", "'peak_res'"))[1] == 0) {}
else{
g <- calipR::get_full_df("db_cq.sqlite", "peak_res")
if(input$base_resp_dual == TRUE){
g <- calipR::base_resp.rm(peaks, full)[[1]]
}
t <- calipR::dual_prop(g, input$stim_list_1, input$stim_list_2)
}
})
output$dual_prop <- DT::renderDataTable(
DT::datatable({t()},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
))
})
### Ajouter des visualisations des pourcentages par groupe, par coverslip etc. :
output$viz <- plotly::renderPlotly({
print(res()[[1]])
print(str(res()[[1]]))
#res <- calipR::get_full_df("db_cq.sqlite", "stats_desc_by_cov_group")
plotly::plot_ly(
type = 'bar',
x = res()[[1]][[input$x]],
y = res()[[1]][[input$y]],
text = paste("Group: ", res()[[1]][["group"]],
"<br>Stimulus:  ", res()[[1]][["stimulus"]],
"<br>Responders: ", res()[[1]][["Responses"]],
"<br>Proportion: ", res()[[1]][["Prop"]],
"<br> Total cells: ", res()[[1]][["n_cells_grp"]]),
hoverinfo = 'text',
marker = list(size = 2),
color = res()[[1]][[input$z]],
) %>%
plotly::layout(barmode ="group", yaxis = list(automargin = TRUE),
xaxis = list(automargin = TRUE), bargap = -2, bargroupgap = 0)
})
full <- calipR::get_full_df("db_cq.sqlite", "df_final")
peaks <- calipR::get_full_df("db_cq.sqlite", "peak_res")
if(is.null(full)){
}
else{
output$resp_viz <- shiny::renderUI({
data <- res_sim$res
responders <- unique(peaks$Cell_id)
shiny::selectInput(inputId = "resp_viz", "Responders", responders)
})
}
if(is.null(full)){
}
else{
output$non_resp_viz <- shiny::renderUI({
data <- res_sim$res
cells <- unique(full$Cell_id)
responders <- unique(peaks$Cell_id)
non_responders <- cells %in% responders
non_responders <- unlist(purrr::map2(cells, non_responders, function(x,y) if(y == FALSE){x}))
shiny::selectInput(inputId = "non_resp_viz", "Non Responders", non_responders)
})
}
shiny::observeEvent(input$plot_button,{
output$plot_resp_viz <- renderPlot({
# OpÃ©rer un tri sur les cellules regarder comment j'ai fais pour responders
p <- cell_plot(full, peaks, var = "Mean_Grey", cell = input$resp_viz, line = "gam", show_peak = FALSE)
p
})
})
shiny::observeEvent(input$plot_button_bis,{
output$plot_non_resp_viz <- renderPlot({
p <- cell_plot(full, peaks, var = "Mean_Grey", cell = input$non_resp_viz, line = "gam", show_peak = FALSE)
p
})
})
}
shiny::shinyApp(ui, server)
}
#' @param deconvolve_var
#' @param borders_range
#' @param time_thresh
#' @param frame_rate
#' @param compare_groups
#'
#' @return
#' @export
#'
#' @examples
downstream_analysis <- function(data, moving_thresh = 0.1, outlier_thresh = 2, mean_width = 20, DPA_width = 10, CN_DPA_width = 20,
mean_width_diff = 10, method = "gam", norm_var = "gam",
norm_width = 10, lambda = 100,
gam = 0.97, constraint = T, threshold = 3,
deconvolve_var = "gam_detrended", borders_range = 50,
time_thresh = 1, compare_groups = FALSE, false_pos = c(TRUE, FALSE), one_cell = FALSE, simulation = FALSE) {
lambda <- as.numeric(lambda)
print(lambda)
gam <- as.numeric(gam)
print(gam)
threshold <- as.numeric(threshold)
print(threshold)
borders_range <- as.integer(borders_range)
print(borders_range)
if(one_cell == FALSE){
shiny::withProgress(message = "Analyzing Full Dataset", value = 0, detail = "Cleaning Data", {
clean <- calipR::clean_data(data, moving_thresh, outlier_thresh, mean_width, CN_DPA_width, DPA_width, mean_width_diff)
print("cleaning = OK")
shiny::incProgress(1/5, detail = "Estimating Background")
back <- calipR::backEstimate(clean, method = method)
print("back = OK")
shiny::incProgress(1/5, detail = "Normalizing Data")
norm <- calipR::norm_df(back, var = norm_var, width = norm_width)
print("norm = OK")
print(norm)
shiny::incProgress(1/5, detail = "Performing Deconvolution")
deconvolved <- deconvolve(norm, lambda = lambda, gam = gam, constraint = constraint,
threshold = threshold, var = deconvolve_var)
print("deconvolved = ok")
print(deconvolved[[1]]$Cell_id)
print(deconvolved[[1]])
if(length(deconvolved[[1]]$Cell_id) != 0){
if(false_pos == TRUE){
shiny::incProgress(1/5, detail = "Removing Estimated False Positives")
deconvolved <- keep_best_peaks(deconvolved)
print("best = ok")
}
}
shiny::incProgress(1/5, detail = "Computing Statistics")
print(deconvolved[[1]])
res <- Analyze_Responses(deconvolved[[1]], clean, compare_groups = compare_groups,
one_cell = FALSE, simulation = simulation)
})
}
if(one_cell == TRUE){
shiny::withProgress(message = "Testing New Parameters", value = 0, detail = "Performing Deconvolution", {
deconvolved <- deconvolve(data, lambda = lambda, gam = gam, constraint = constraint,
threshold = threshold, var = deconvolve_var)
print("deconvolved :")
print(deconvolved)
print("deconvolved = ok")
print(deconvolved[[1]]$Cell_id)
if(length(deconvolved[[1]]$Cell_id) != 0){
if(false_pos == TRUE){
deconvolved <- keep_best_peaks(deconvolved)
print(deconvolved)
#else{
#shiny::incProgress(1/2, detail = "Finding Peaks Borders")
#borders <- calipR::find_borders(best, range = borders_range)
#}
}
#if(false_pos == FALSE){
#shiny::incProgress(1/2, detail = "Finding Peaks Borders")
#borders <- calipR::find_borders(deconvolved, range = borders_range)
#}
}
res <- "NO RES"
norm <- data
})
}
print("finished Downstream analysis")
print(deconvolved)
print("YEAH")
return(list(deconvolved[[1]], deconvolved[[2]], res))
}
#' @param constraint
#' @param estimate_calcium
#' @param var
#' @param ESP
#' @param threshold
#'
#' @return
#' @export
#'
#' @examples
deconvolve <- function(norm_data, gam = 0.95, lambda = 1, constraint = T, estimate_calcium = T, var = "gam_detrended", ESP = 0.0001,
threshold = 3) {
cells <- unique(norm_data$Cell_id)
cell_split <- split(norm_data, norm_data$Cell_id)
print("first_split = ok")
cell_split <- lapply(cell_split, function(x) add_peak_info(x, gam = gam, lambda = lambda,constraint, estimate_calcium, var, ESP))
print("add peak info = OK ")
peaks_data <- lapply(cell_split, function(x) if(length(x$peak_frames)[[1]] != 0) {x[x$time_frame %in% x$peak_frames[[1]]]} )
print("discreted peaks ")
print("discreted peaks ")
peaks_data <- lapply(peaks_data, function(x) if(dim(x)[[1]] != 0) {x[, frame_window := x$time_frame +20]} )
print("frame window created ")
data <- do.call(rbind, cell_split)
peaks_data <- do.call(rbind, peaks_data)
print(peaks_data)
print(length(peaks_data$Cell_id))
if(length(peaks_data$Cell_id) != 0) {
peaks_data <- split(peaks_data,cumsum(1:nrow(peaks_data) %in% seq(1:nrow(peaks_data))))
print(length(lapply(peaks_data, function(x) data[data$smooth_z == max(data[data$Cell_id == x$Cell_id & data$time_frame %between%
list(x$time_frame, x$frame_window)]$smooth_z)[[1]]]$smooth_z[[1]])))
print(length(lapply(peaks_data, function(x) data[data$smooth_z == max(data[data$Cell_id == x$Cell_id & data$time_frame %between%
list(x$time_frame, x$frame_window)]$smooth_z)[[1]]][1,]$smooth_z)))
smooth_z <- unlist(lapply(peaks_data, function(x) data[data$smooth_z == max(data[data$Cell_id == x$Cell_id & data$time_frame %between%
list(x$time_frame, x$frame_window)]$smooth_z)[[1]]]$smooth_z[[1]]))
max_frame <- unlist(lapply(peaks_data, function(x) data[data$smooth_z == max(data[data$Cell_id == x$Cell_id & data$time_frame %between%
list(x$time_frame, x$frame_window)]$smooth_z)[[1]]]$time_frame[[1]]))
print(length(smooth_z))
peaks_data <- do.call(rbind, peaks_data)
print(length(peaks_data$Cell_id))
peaks_data$max_peak_smooth_z <- smooth_z
peaks_data$Max_peak_frame <- max_frame
#print(peaks_data)
print("DONNEE")
print("subset ok" )
#print(peaks_data)
}
peaks_data <- split(peaks_data,cumsum(1:nrow(peaks_data) %in% seq(1:nrow(peaks_data))))
peaks_data <- lapply(peaks_data, function(x) if(x$max_peak_smooth_z[[1]] >= threshold) {x} )
peaks_data <- do.call(rbind, peaks_data)
# print(peaks_data)
#peaks_data <- split(peaks_data,cumsum(1:nrow(peaks_data) %in% seq(1:nrow(peaks_data))))
print("split ok")
print("threshold ok" )
# peaks_data <- do.call(rbind, peaks_data)
if(is.null(peaks_data) == FALSE) {
peaks_data <- dplyr::rename(peaks_data,  "spike_stimulus" = "stimulus", "spike_frame" = "time_frame", "spike_stimulation" = "Stimulation",
"spike_smooth_z" = "smooth_z", "spike_first_derivative" = "first_derivative" )
peaks_data <- unique(peaks_data[,c("Cell_id", "spike_frame", "spike_stimulus", "spike_smooth_z", "Mean_Grey", "gam_detrended", "Max_peak_frame")])
}
#print(peaks_data)
print("peaks_data")
#data$marker_positive <- as.factor(data$marker_positive)
mark_lev <- unique(data$marker_positive)
data$marker_positive <- factor(data$marker_positive, levels = mark_lev, ordered = TRUE)
#data$group <- as.factor(data$group)
group_lev <- unique(data$group)
data$group  <- factor(data$group, levels = group_lev, ordered = TRUE)
#data$stimulus <- as.factor(data$stimulus)
stim_lev <- unique(data$stimulus)
data$stimulus  <- factor(data$stimulus, levels = stim_lev, ordered = TRUE)
#data$coverslip <- as.factor(data$coverslip)
cov_lev <- unique(data$coverslip)
data$coverslip  <- factor(data$coverslip, levels = cov_lev, ordered = TRUE)
#data <- data[, peak_frames:= NULL]
print(data)
print(peaks_data)
print("hou")
return(list(peaks_data, data))
}
launch_GuiGui()
#' @param constraint
#' @param estimate_calcium
#' @param var
#' @param ESP
#' @param threshold
#'
#' @return
#' @export
#'
#' @examples
deconvolve <- function(norm_data, gam = 0.95, lambda = 1, constraint = T, estimate_calcium = T, var = "gam_detrended", ESP = 0.0001,
threshold = 3) {
cells <- unique(norm_data$Cell_id)
cell_split <- split(norm_data, norm_data$Cell_id)
print("first_split = ok")
cell_split <- lapply(cell_split, function(x) add_peak_info(x, gam = gam, lambda = lambda,constraint, estimate_calcium, var, ESP))
print("add peak info = OK ")
peaks_data <- lapply(cell_split, function(x) if(length(x$peak_frames)[[1]] != 0) {x[x$time_frame %in% x$peak_frames[[1]]]} )
print("discreted peaks ")
print("discreted peaks ")
peaks_data <- lapply(peaks_data, function(x) if(dim(x)[[1]] != 0) {x[, frame_window := x$time_frame +20]} )
print("frame window created ")
data <- do.call(rbind, cell_split)
peaks_data <- do.call(rbind, peaks_data)
print(peaks_data)
print(length(peaks_data$Cell_id))
if(length(peaks_data$Cell_id) != 0) {
peaks_data <- split(peaks_data,cumsum(1:nrow(peaks_data) %in% seq(1:nrow(peaks_data))))
print(length(lapply(peaks_data, function(x) data[data$smooth_z == max(data[data$Cell_id == x$Cell_id & data$time_frame %between%
list(x$time_frame, x$frame_window)]$smooth_z)[[1]]]$smooth_z[[1]])))
print(length(lapply(peaks_data, function(x) data[data$smooth_z == max(data[data$Cell_id == x$Cell_id & data$time_frame %between%
list(x$time_frame, x$frame_window)]$smooth_z)[[1]]][1,]$smooth_z)))
smooth_z <- unlist(lapply(peaks_data, function(x) data[data$smooth_z == max(data[data$Cell_id == x$Cell_id & data$time_frame %between%
list(x$time_frame, x$frame_window)]$smooth_z)[[1]]]$smooth_z[[1]]))
max_frame <- unlist(lapply(peaks_data, function(x) data[data$smooth_z == max(data[data$Cell_id == x$Cell_id & data$time_frame %between%
list(x$time_frame, x$frame_window)]$smooth_z)[[1]]]$time_frame[[1]]))
print(length(smooth_z))
peaks_data <- do.call(rbind, peaks_data)
print(length(peaks_data$Cell_id))
peaks_data$max_peak_smooth_z <- smooth_z
peaks_data$Max_peak_frame <- max_frame
#print(peaks_data)
print("DONNEE")
print("subset ok" )
#print(peaks_data)
}
peaks_data <- split(peaks_data,cumsum(1:nrow(peaks_data) %in% seq(1:nrow(peaks_data))))
peaks_data <- lapply(peaks_data, function(x) if(x$max_peak_smooth_z[[1]] >= threshold) {x} )
peaks_data <- do.call(rbind, peaks_data)
# print(peaks_data)
#peaks_data <- split(peaks_data,cumsum(1:nrow(peaks_data) %in% seq(1:nrow(peaks_data))))
print("split ok")
print("threshold ok" )
# peaks_data <- do.call(rbind, peaks_data)
if(is.null(peaks_data) == FALSE) {
peaks_data <- dplyr::rename(peaks_data,  "spike_stimulus" = "stimulus", "spike_frame" = "time_frame", "spike_stimulation" = "Stimulation",
"spike_smooth_z" = "smooth_z", "spike_first_derivative" = "first_derivative" )
peaks_data <- unique(peaks_data[,c("Cell_id", "spike_frame", "spike_stimulus", "spike_smooth_z", "Mean_Grey", "gam_detrended", "Max_peak_frame")])
}
#print(peaks_data)
print("peaks_data")
print(data)
print(peaks_data)
print("hou")
return(list(peaks_data, data))
}
