embedding = 2, n = 1)$dsignal[,2]])
cell_split <- lapply(cell_split, function(x) x[ , smooth_Diff := gplots::wapply(x$time_frame, x$first_derivative, fun = mean, n =length(data$time_frame), width = mean_width_diff, method = "nobs", drop.na = FALSE)[[2]]])
print(cell_split[[1]])
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, c("DPA", "CN_DPA") := list(DPA(x, DPA_width),  CN_DPA(x, CN_DPA_width))])
print("DPA DOOONE")
print("CN_DPA DOOONE")
cell_split <- lapply(cell_split, function(x) x[, c("DPA", "CN_DPA") :=
list(replace(DPA, is.na(DPA),quantile_speed(DPA, probs = .5)),
replace(CN_DPA, is.na(CN_DPA), quantile_speed(CN_DPA, probs = .5)))])
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[,
c("smooth_DPA", "smooth_CN_DPA") := list(gplots::wapply(x$time_frame, x$DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]],
gplots::wapply(x$time_frame, x$CN_DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, smooth_CN_DPA > quantile_speed(smooth_CN_DPA, probs = .7, na.rm = T)|
Mean_Grey < (mean(Mean_Grey) - 2*stats::sd(Mean_Grey)),
NaN)])
print(cell_split[[1]])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == max(time_frame) & is.na(Mean_Grey_wo_peaks), local_mean[ max(time_frame)])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == 1 & is.na(Mean_Grey_wo_peaks), local_mean[1])])
print(cell_split[[1]])
lapply(cell_split, function(x) if(length(is.na(x$Mean_Grey_wo_peaks)[is.na(x$Mean_Grey_wo_peaks)[TRUE]]) == length(x$Mean_Grey_wo_peaks)) {print(x)})
#cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, smooth_DPA > quantile_speed(smooth_DPA, probs = .5)
# |Mean_Grey < (mean(Mean_Grey) - 2*stats::sd(Mean_Grey)),
# NaN)])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := approxfun(which(!is.na(Mean_Grey_wo_peaks)), na.omit(Mean_Grey_wo_peaks))(seq_along(Mean_Grey_wo_peaks))])
print("OKKKK")
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := gplots::wapply(x$time_frame, x$Mean_Grey_wo_peaks,
fun = function(x) quantile_speed(x, probs = .1), n = length(x$time_frame), width = 30, method = "nobs")[[2]]])
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
data <- moving_cells(cell_split, threshold = moving_threshold)
print(paste("Number of cells after cleaning", length(unique(data$Cell_id)), sep = ": " ))
print(paste("Removed", ncells_before - length(unique(data$Cell_id)), "cells", sep = " " ))
return(data)
}
launch_GuiGui()
#' @param deconvolve_var
#' @param borders_range
#' @param time_thresh
#' @param frame_rate
#' @param compare_groups
#'
#' @return
#' @export
#'
#' @examples
downstream_analysis <- function(data, moving_thresh = 0.1, outlier_thresh = 2, mean_width = 20, DPA_width = 10, CN_DPA_width = 80,
mean_width_diff = 10, method = "gam", norm_var = "gam",
norm_width = 10, lambda = 100,
gam = 0.97, constraint = T, threshold = 3,
deconvolve_var = "gam_detrended", borders_range = 50,
time_thresh = 1, compare_groups = FALSE, false_pos = c(TRUE, FALSE), one_cell = FALSE) {
lambda <- as.numeric(lambda)
print(lambda)
gam <- as.numeric(gam)
print(gam)
threshold <- as.numeric(threshold)
print(threshold)
borders_range <- as.integer(borders_range)
print(borders_range)
if(one_cell == FALSE){
shiny::withProgress(message = "Analyzing Full Dataset", value = 0, detail = "Cleaning Data", {
clean <- clean_data_old(data, moving_thresh, outlier_thresh, mean_width, CN_DPA_width, DPA_width, mean_width_diff)
print("cleaning = OK")
shiny::incProgress(1/6, detail = "Estimating Background")
back <- calipR::backEstimate(clean, method = method)
print("back = OK")
shiny::incProgress(1/6, detail = "Normalizing Data")
norm <- calipR::norm_df(back, var = norm_var, width = norm_width)
print("norm = OK")
print(norm)
shiny::incProgress(1/6, detail = "Performing Deconvolution")
deconvolved <- calipR::deconvolve(norm, lambda = lambda, gam = gam, constraint = constraint,
threshold = threshold, var = deconvolve_var)
print("deconvolved = ok")
print(deconvolved[[1]]$Cell_id)
if(length(deconvolved[[1]]$Cell_id) == 0){
borders <- NULL
print(borders)
}
if(length(deconvolved[[1]]$Cell_id) != 0){
if(false_pos == TRUE){
best <- calipR::keep_best_peaks(deconvolved)
print("best = ok")
if(length(best[[1]]$Cell_id) == 0 ){
borders <- NULL
}
else{
shiny::incProgress(1/6, detail = "Finding Peaks Borders")
borders <- calipR::find_borders(best, range = borders_range)
}
}
if(false_pos == FALSE){
shiny::incProgress(1/6, detail = "Finding Peaks Borders")
borders <- calipR::find_borders(deconvolved, range = borders_range)
}
}
shiny::incProgress(1/6, detail = "Computing Statistics")
res <- calipR::Analyze_Responses(borders[[1]], clean, compare_groups = compare_groups, one_cell = FALSE)
})
}
if(one_cell == TRUE){
shiny::withProgress(message = "Testing New Parameters", value = 0, detail = "Performing Deconvolution", {
deconvolved <- calipR::deconvolve(data, lambda = lambda, gam = gam, constraint = constraint,
threshold = threshold, var = deconvolve_var)
print("deconvolved = ok")
print(deconvolved[[1]]$Cell_id)
if(length(deconvolved[[1]]$Cell_id) == 0){
borders <- NULL
print(borders)
}
if(length(deconvolved[[1]]$Cell_id) != 0){
if(false_pos == TRUE){
best <- calipR::keep_best_peaks(deconvolved)
print("best = ok")
if(length(best[[1]]$Cell_id) == 0 ){
borders <- NULL
}
else{
shiny::incProgress(1/2, detail = "Finding Peaks Borders")
borders <- calipR::find_borders(best, range = borders_range)
}
}
if(false_pos == FALSE){
shiny::incProgress(1/2, detail = "Finding Peaks Borders")
borders <- calipR::find_borders(deconvolved, range = borders_range)
}
}
res <- "NO RES"
norm <- data
})
}
return(list(borders[[1]], norm, res))
}
launch_GuiGui()
#' moving_cells
#'
#' @param data
#' @param threshold An optional parameter defining over how many standard deviations (of the baseline)
#' a decrease in median during a stimulus will be considered a moving cell and thus discarded.
#'
#' @return a data frame with all moving cells removed
#' @export
#'
#' @examples
moving_cells_old <- function(data, threshold = 0.1){
data <- data.table::setDT(data)[, Moving_cells := sum(Mean_Grey == 0) / sum(Mean_Grey >= 0) > threshold]
data <- data.table::setDT(data)[, Anormal_variation := LaplacesDemon::is.bimodal(Mean_Grey)]
return(data)
}
#' @param DPA_width
#' @param CN_DPA_width
#' @param mean_width_diff
#' @param mean_width_second
#' @param data a data.table output from prepareData function
#'
#' @return
#' @export
#'
#' @examples
clean_data_old <- function(data, moving_threshold, outlier_threshold ,mean_width, DPA_width, CN_DPA_width, mean_width_diff, mean_width_second){
ncells_before <- length(unique(data$Cell_id))
print(paste("Number of cells before cleaning", ncells_before, sep = ": " ))
# Splitting the data frame by cell_id
cell_split <- split(data, data$Cell_id)
# Removing Cells with too much Nas :
#cell_split <- lapply(cell_split, function(x) if(length(do.call(rbind, lapply(is.na(x$Mean_Grey), function(x) if(x == TRUE) x))[,1])/length(x$Mean_Grey) < moving_threshold) {x} )
cell_split <- lapply(cell_split, function(x) if((length(do.call(rbind, lapply(is.na(x$Mean_Grey), function(x) if(x == TRUE) x))[,1]) / length(x$Mean_Grey)) < moving_threshold) x)
cell_split <- cell_split[cell_split != "NULL"]
# Computing a local mean for each data.table
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, local_mean := gplots::wapply(x$time_frame, x$Mean_Grey, fun = mean, n=length(x$time_frame), width = mean_width, method = "nobs")[[2]]])
#cell_split <- lapply(cell_split, function(x) x$Mean_Grey[x$time_frame == 1 & x$Mean_Grey == 0] <- x$local_mean[x$time_frame == 1 & x$Mean_Grey == 0])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey := replace(Mean_Grey, time_frame == 1 & Mean_Grey == 0, local_mean[1])])
# Computing first derivative
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, first_derivative := doremi::calculate.gold(time = x$time_seconds, signal = x$local_mean,
embedding = 2, n = 1)$dsignal[,2]])
cell_split <- lapply(cell_split, function(x) x[ , smooth_Diff := gplots::wapply(x$time_frame, x$first_derivative, fun = mean, n =length(data$time_frame), width = mean_width_diff, method = "nobs", drop.na = FALSE)[[2]]])
print(cell_split[[1]])
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, c("DPA", "CN_DPA") := list(DPA(x, DPA_width),  CN_DPA(x, CN_DPA_width))])
print("DPA DOOONE")
print("CN_DPA DOOONE")
cell_split <- lapply(cell_split, function(x) x[, c("DPA", "CN_DPA") :=
list(replace(DPA, is.na(DPA),quantile_speed(DPA, probs = .5)),
replace(CN_DPA, is.na(CN_DPA), quantile_speed(CN_DPA, probs = .5)))])
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[,
c("smooth_DPA", "smooth_CN_DPA") := list(gplots::wapply(x$time_frame, x$DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]],
gplots::wapply(x$time_frame, x$CN_DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, smooth_CN_DPA > quantile_speed(smooth_CN_DPA, probs = .7, na.rm = T)|
Mean_Grey < (mean(Mean_Grey) - 2*stats::sd(Mean_Grey)),
NaN)])
print(cell_split[[1]])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == max(time_frame) & is.na(Mean_Grey_wo_peaks), local_mean[ max(time_frame)])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == 1 & is.na(Mean_Grey_wo_peaks), local_mean[1])])
print(cell_split[[1]])
lapply(cell_split, function(x) if(length(is.na(x$Mean_Grey_wo_peaks)[is.na(x$Mean_Grey_wo_peaks)[TRUE]]) == length(x$Mean_Grey_wo_peaks)) {print(x)})
#cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, smooth_DPA > quantile_speed(smooth_DPA, probs = .5)
# |Mean_Grey < (mean(Mean_Grey) - 2*stats::sd(Mean_Grey)),
# NaN)])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := approxfun(which(!is.na(Mean_Grey_wo_peaks)), na.omit(Mean_Grey_wo_peaks))(seq_along(Mean_Grey_wo_peaks))])
print("OKKKK")
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := gplots::wapply(x$time_frame, x$Mean_Grey_wo_peaks,
fun = function(x) quantile_speed(x, probs = .1), n = length(x$time_frame), width = 30, method = "nobs")[[2]]])
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
data <- moving_cells_old(cell_split, threshold = moving_threshold)
print(paste("Number of cells after cleaning", length(unique(data$Cell_id)), sep = ": " ))
print(paste("Removed", ncells_before - length(unique(data$Cell_id)), "cells", sep = " " ))
return(data)
}
launch_GuiGui()
#' moving_cells
#'
#' @param data
#' @param threshold An optional parameter defining over how many standard deviations (of the baseline)
#' a decrease in median during a stimulus will be considered a moving cell and thus discarded.
#'
#' @return a data frame with all moving cells removed
#' @export
#'
#' @examples
moving_cells_old <- function(data, threshold = 0.1){
data <- lapply(data, function(x) data.table::setDT(x)[, Moving_cells := sum(Mean_Grey == 0) / sum(Mean_Grey >= 0) > threshold])
data <- lapply(data, function(x) data.table::setDT(x)[, Anormal_variation := LaplacesDemon::is.bimodal(Mean_Grey)])
return(data)
}
#' @param DPA_width
#' @param CN_DPA_width
#' @param mean_width_diff
#' @param mean_width_second
#' @param data a data.table output from prepareData function
#'
#' @return
#' @export
#'
#' @examples
clean_data_old <- function(data, moving_threshold, outlier_threshold ,mean_width, DPA_width, CN_DPA_width, mean_width_diff, mean_width_second){
ncells_before <- length(unique(data$Cell_id))
print(paste("Number of cells before cleaning", ncells_before, sep = ": " ))
# Splitting the data frame by cell_id
cell_split <- split(data, data$Cell_id)
# Removing Cells with too much Nas :
#cell_split <- lapply(cell_split, function(x) if(length(do.call(rbind, lapply(is.na(x$Mean_Grey), function(x) if(x == TRUE) x))[,1])/length(x$Mean_Grey) < moving_threshold) {x} )
cell_split <- lapply(cell_split, function(x) if((length(do.call(rbind, lapply(is.na(x$Mean_Grey), function(x) if(x == TRUE) x))[,1]) / length(x$Mean_Grey)) < moving_threshold) x)
cell_split <- cell_split[cell_split != "NULL"]
# Computing a local mean for each data.table
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, local_mean := gplots::wapply(x$time_frame, x$Mean_Grey, fun = mean, n=length(x$time_frame), width = mean_width, method = "nobs")[[2]]])
#cell_split <- lapply(cell_split, function(x) x$Mean_Grey[x$time_frame == 1 & x$Mean_Grey == 0] <- x$local_mean[x$time_frame == 1 & x$Mean_Grey == 0])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey := replace(Mean_Grey, time_frame == 1 & Mean_Grey == 0, local_mean[1])])
# Computing first derivative
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, first_derivative := doremi::calculate.gold(time = x$time_seconds, signal = x$local_mean,
embedding = 2, n = 1)$dsignal[,2]])
cell_split <- lapply(cell_split, function(x) x[ , smooth_Diff := gplots::wapply(x$time_frame, x$first_derivative, fun = mean, n =length(data$time_frame), width = mean_width_diff, method = "nobs", drop.na = FALSE)[[2]]])
print(cell_split[[1]])
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, c("DPA", "CN_DPA") := list(DPA(x, DPA_width),  CN_DPA(x, CN_DPA_width))])
print("DPA DOOONE")
print("CN_DPA DOOONE")
cell_split <- lapply(cell_split, function(x) x[, c("DPA", "CN_DPA") :=
list(replace(DPA, is.na(DPA),quantile_speed(DPA, probs = .5)),
replace(CN_DPA, is.na(CN_DPA), quantile_speed(CN_DPA, probs = .5)))])
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[,
c("smooth_DPA", "smooth_CN_DPA") := list(gplots::wapply(x$time_frame, x$DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]],
gplots::wapply(x$time_frame, x$CN_DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, smooth_CN_DPA > quantile_speed(smooth_CN_DPA, probs = .7, na.rm = T)|
Mean_Grey < (mean(Mean_Grey) - 2*stats::sd(Mean_Grey)),
NaN)])
print(cell_split[[1]])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == max(time_frame) & is.na(Mean_Grey_wo_peaks), local_mean[ max(time_frame)])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == 1 & is.na(Mean_Grey_wo_peaks), local_mean[1])])
print(cell_split[[1]])
lapply(cell_split, function(x) if(length(is.na(x$Mean_Grey_wo_peaks)[is.na(x$Mean_Grey_wo_peaks)[TRUE]]) == length(x$Mean_Grey_wo_peaks)) {print(x)})
#cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, smooth_DPA > quantile_speed(smooth_DPA, probs = .5)
# |Mean_Grey < (mean(Mean_Grey) - 2*stats::sd(Mean_Grey)),
# NaN)])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := approxfun(which(!is.na(Mean_Grey_wo_peaks)), na.omit(Mean_Grey_wo_peaks))(seq_along(Mean_Grey_wo_peaks))])
print("OKKKK")
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := gplots::wapply(x$time_frame, x$Mean_Grey_wo_peaks,
fun = function(x) quantile_speed(x, probs = .1), n = length(x$time_frame), width = 30, method = "nobs")[[2]]])
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
data <- moving_cells_old(cell_split, threshold = moving_threshold)
data <- do.call(rbind, cell_split)
print(paste("Number of cells after cleaning", length(unique(data$Cell_id)), sep = ": " ))
print(paste("Removed", ncells_before - length(unique(data$Cell_id)), "cells", sep = " " ))
return(data)
}
launch_GuiGui()
#'generalized additive model (GAM) or 8th percentile.
#'
#' @param data a data frame output from PrepareData function
#' @param method One method among the 4 possible options : "linear", "polynomial", "gam", "quantile"
#'
#' @return a data table object with 5 new columns : a local mean, the first derivative, the DPA, the mean grey values with peak values replaced by 10th percentile and the fitted values with the chosen method (the background estimation)
#' @export
#'
#' @examples
#'
backEstimate <- function(data, smooth = 50, method = c("smooth","gam")){
#noise_model <- readRDS(system.file("model/noise_model.rds", package = "calipR"))
#data <- data %>%
# dplyr::bind_cols(
#  stats::predict(noise_model, data),
# stats::predict(noise_model, data, type = "prob" )
#)
cell_split <- split(data,data$Cell_id)
#print(cell_split)
#cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, signal :=
#                            ifelse(x$.pred_signal > 0.5 | x$smooth_DPA >
#                                     mean(x$smooth_DPA)*0.8 | x$smooth_Diff < 1 , TRUE, FALSE)])
# cell_split <- lapply(cell_split, function(x) x[, noise :=
#                                                 ifelse(x$.pred_noise > 0.7 | x$smooth_DPA <
#                                                         0.5*mean(x$smooth_DPA)|
#                                                        x$Mean_Grey <
#                                                       mean(x$Mean_Grey),TRUE, FALSE)])
#print("noise = ok")
#cell_split <- lapply(cell_split, function(x) x[, noise := replace(noise, time_frame == max(time_frame), TRUE)])
#cell_split <-  lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, signal == TRUE & noise == FALSE,NaN)])
#cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := approxfun(which(!is.na(Mean_Grey_wo_peaks)), na.omit(Mean_Grey_wo_peaks))(seq_along(Mean_Grey_wo_peaks))])
#data <- do.call(rbind, cell_split)
#data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
print("mean_grey wo peaks ok")
cell_split <- split(data, data$Cell_id)
if(method == "smooth"){
cell_split  <- lapply(cell_split , function(x) x[, gam_fit := gplots::wapply(x$time_frame, x$Mean_Grey_wo_peaks, fun = mean, n=length(x$time_frame), width = smooth, method = "nobs")[[2]]])
cell_split <- lapply(cell_split, function(x) x[, gam_detrended := Mean_Grey - gam_fit])
}
if(method == "gam"){
cell_split <- lapply(cell_split, function(x) x[, gam_fit := mgcv::gam(Mean_Grey_wo_peaks ~ s(time_frame, bs = "cr", k = 11), data = x, gamma = 2)[[3]]])
cell_split <- lapply(cell_split, function(x) x[, gam_detrended := Mean_Grey - gam_fit])
}
data <- do.call(rbind, cell_split)
print("ok")
return(data)
}
launch_GuiGui()
#' @param deconvolve_var
#' @param borders_range
#' @param time_thresh
#' @param frame_rate
#' @param compare_groups
#'
#' @return
#' @export
#'
#' @examples
downstream_analysis <- function(data, moving_thresh = 0.1, outlier_thresh = 2, mean_width = 20, DPA_width = 10, CN_DPA_width = 80,
mean_width_diff = 10, method = "gam", norm_var = "gam",
norm_width = 10, lambda = 100,
gam = 0.97, constraint = T, threshold = 3,
deconvolve_var = "gam_detrended", borders_range = 50,
time_thresh = 1, compare_groups = FALSE, false_pos = c(TRUE, FALSE), one_cell = FALSE) {
lambda <- as.numeric(lambda)
print(lambda)
gam <- as.numeric(gam)
print(gam)
threshold <- as.numeric(threshold)
print(threshold)
borders_range <- as.integer(borders_range)
print(borders_range)
if(one_cell == FALSE){
shiny::withProgress(message = "Analyzing Full Dataset", value = 0, detail = "Cleaning Data", {
clean <- clean_data_old(data, moving_thresh, outlier_thresh, mean_width, CN_DPA_width, DPA_width, mean_width_diff)
print("cleaning = OK")
shiny::incProgress(1/6, detail = "Estimating Background")
back <- backEstimate(clean, method = method)
print("back = OK")
shiny::incProgress(1/6, detail = "Normalizing Data")
norm <- calipR::norm_df(back, var = norm_var, width = norm_width)
print("norm = OK")
print(norm)
shiny::incProgress(1/6, detail = "Performing Deconvolution")
deconvolved <- calipR::deconvolve(norm, lambda = lambda, gam = gam, constraint = constraint,
threshold = threshold, var = deconvolve_var)
print("deconvolved = ok")
print(deconvolved[[1]]$Cell_id)
if(length(deconvolved[[1]]$Cell_id) == 0){
borders <- NULL
print(borders)
}
if(length(deconvolved[[1]]$Cell_id) != 0){
if(false_pos == TRUE){
best <- calipR::keep_best_peaks(deconvolved)
print("best = ok")
if(length(best[[1]]$Cell_id) == 0 ){
borders <- NULL
}
else{
shiny::incProgress(1/6, detail = "Finding Peaks Borders")
borders <- calipR::find_borders(best, range = borders_range)
}
}
if(false_pos == FALSE){
shiny::incProgress(1/6, detail = "Finding Peaks Borders")
borders <- calipR::find_borders(deconvolved, range = borders_range)
}
}
shiny::incProgress(1/6, detail = "Computing Statistics")
res <- calipR::Analyze_Responses(borders[[1]], clean, compare_groups = compare_groups, one_cell = FALSE)
})
}
if(one_cell == TRUE){
shiny::withProgress(message = "Testing New Parameters", value = 0, detail = "Performing Deconvolution", {
deconvolved <- calipR::deconvolve(data, lambda = lambda, gam = gam, constraint = constraint,
threshold = threshold, var = deconvolve_var)
print("deconvolved = ok")
print(deconvolved[[1]]$Cell_id)
if(length(deconvolved[[1]]$Cell_id) == 0){
borders <- NULL
print(borders)
}
if(length(deconvolved[[1]]$Cell_id) != 0){
if(false_pos == TRUE){
best <- calipR::keep_best_peaks(deconvolved)
print("best = ok")
if(length(best[[1]]$Cell_id) == 0 ){
borders <- NULL
}
else{
shiny::incProgress(1/2, detail = "Finding Peaks Borders")
borders <- calipR::find_borders(best, range = borders_range)
}
}
if(false_pos == FALSE){
shiny::incProgress(1/2, detail = "Finding Peaks Borders")
borders <- calipR::find_borders(deconvolved, range = borders_range)
}
}
res <- "NO RES"
norm <- data
})
}
return(list(borders[[1]], norm, res))
}
launch_GuiGui()
library(calipR)
library(calipR)
launch_GuiGui()
#' @param DPA_width
#' @param CN_DPA_width
#' @param mean_width_diff
#' @param mean_width_second
#' @param data a data.table output from prepareData function
#'
#' @return
#' @export
#'
#' @examples
clean_data <- function(data, moving_threshold, outlier_threshold ,mean_width, DPA_width, CN_DPA_width, mean_width_diff, mean_width_second){
ncells_before <- length(unique(data$Cell_id))
print(paste("Number of cells before cleaning", ncells_before, sep = ": " ))
# Splitting the data frame by cell_id
cell_split <- split(data, data$Cell_id)
# Removing Cells with too much Nas :
#cell_split <- lapply(cell_split, function(x) if(length(do.call(rbind, lapply(is.na(x$Mean_Grey), function(x) if(x == TRUE) x))[,1])/length(x$Mean_Grey) < moving_threshold) {x} )
cell_split <- lapply(cell_split, function(x) if((length(do.call(rbind, lapply(is.na(x$Mean_Grey), function(x) if(x == TRUE) x))[,1]) / length(x$Mean_Grey)) < moving_threshold) x)
cell_split <- cell_split[cell_split != "NULL"]
# Computing a local mean for each data.table
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, local_mean := gplots::wapply(x$time_frame, x$Mean_Grey, fun = mean, n=length(x$time_frame), width = mean_width, method = "nobs")[[2]]])
#cell_split <- lapply(cell_split, function(x) x$Mean_Grey[x$time_frame == 1 & x$Mean_Grey == 0] <- x$local_mean[x$time_frame == 1 & x$Mean_Grey == 0])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey := replace(Mean_Grey, time_frame == 1 & Mean_Grey == 0, local_mean[1])])
# Computing first derivative
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, first_derivative := doremi::calculate.gold(time = x$time_seconds, signal = x$local_mean,
embedding = 2, n = 1)$dsignal[,2]])
cell_split <- lapply(cell_split, function(x) x[ , smooth_Diff := gplots::wapply(x$time_frame, x$first_derivative, fun = mean, n =length(data$time_frame), width = mean_width_diff, method = "nobs", drop.na = FALSE)[[2]]])
print(cell_split[[1]])
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, c("DPA", "CN_DPA") := list(DPA(x, DPA_width),  CN_DPA(x, CN_DPA_width))])
print("DPA DOOONE")
print("CN_DPA DOOONE")
cell_split <- lapply(cell_split, function(x) x[, c("DPA", "CN_DPA") :=
list(replace(DPA, is.na(DPA),quantile_speed(DPA, probs = .5)),
replace(CN_DPA, is.na(CN_DPA), quantile_speed(CN_DPA, probs = .5)))])
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[,
c("smooth_DPA", "smooth_CN_DPA") := list(gplots::wapply(x$time_frame, x$DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]],
gplots::wapply(x$time_frame, x$CN_DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, smooth_CN_DPA > quantile_speed(smooth_CN_DPA, probs = .7, na.rm = T)|
Mean_Grey < (mean(Mean_Grey) - 1.5*stats::sd(Mean_Grey)),
NaN)])
print(cell_split[[1]])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == max(time_frame) & is.na(Mean_Grey_wo_peaks), local_mean[ max(time_frame)])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == 1 & is.na(Mean_Grey_wo_peaks), local_mean[1])])
print(cell_split[[1]])
lapply(cell_split, function(x) if(length(is.na(x$Mean_Grey_wo_peaks)[is.na(x$Mean_Grey_wo_peaks)[TRUE]]) == length(x$Mean_Grey_wo_peaks)) {print(x)})
#cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, smooth_DPA > quantile_speed(smooth_DPA, probs = .5)
# |Mean_Grey < (mean(Mean_Grey) - 2*stats::sd(Mean_Grey)),
# NaN)])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := approxfun(which(!is.na(Mean_Grey_wo_peaks)), na.omit(Mean_Grey_wo_peaks))(seq_along(Mean_Grey_wo_peaks))])
print("OKKKK")
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := gplots::wapply(x$time_frame, x$Mean_Grey_wo_peaks,
fun = function(x) quantile_speed(x, probs = .1), n = length(x$time_frame), width = 30, method = "nobs")[[2]]])
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
data <- moving_cells_old(cell_split, threshold = moving_threshold)
data <- do.call(rbind, cell_split)
print(paste("Number of cells after cleaning", length(unique(data$Cell_id)), sep = ": " ))
print(paste("Removed", ncells_before - length(unique(data$Cell_id)), "cells", sep = " " ))
return(data)
}
library(calipR)
