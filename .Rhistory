peaks_data <- do.call(rbind, peaks_data)
if(length(peaks_data$Cell_id) != 0) {
# For each spike, get it and the 21 lines that follow it then find the max peak
# and only keep that line
dt <- subset_spike_frames(norm_data,peaks_data)
dt <- dt[, Max_by_20 := max(smooth_z, na.rm = TRUE), by = blocs]
dt <- dt[Max_by_20 ==  smooth_z]
peaks_data$Max_peak_frame <- dt$time_frame
peaks_data$max_peak_smooth_z <- dt$smooth_z
}
# Remove NAs and spikes with a max peak below threshold
peaks_data <- peaks_data[!is.na(max_peak_smooth_z) & max_peak_smooth_z >= threshold]
if(is.null(peaks_data) == FALSE) {
peaks_data <- dplyr::rename(peaks_data,  "spike_stimulus" = "stimulus", "spike_frame" = "time_frame", "spike_stimulation" = "Stimulation",
"spike_smooth_z" = "smooth_z", "spike_first_derivative" = "first_derivative" )
peaks_data <- unique(peaks_data[,c("Cell_id", "spike_frame", "spike_stimulus",
"spike_smooth_z", "Mean_Grey", "gam_detrended", "Max_peak_frame", "max_peak_smooth_z" )])
}
return(list(peaks_data, data))
}
test_deconvolve <- deconvolve(test_VNO_norm_1Hz, lambda = 1, gam = 0.90, constraint =T, threshold = 3)
#' @param constraint
#' @param estimate_calcium
#' @param var
#' @param ESP
#' @param threshold
#'
#' @return
#' @export
#'
#' @examples
deconvolve_vec <- function(norm_data, gam = 0.95, lambda = 1, constraint = T, estimate_calcium = T, var = "gam_detrended", ESP = 0.0001,
threshold = 3) {
cells <- unique(norm_data$Cell_id)
cell_split <- split(norm_data, norm_data$Cell_id)
cell_split <- lapply(cell_split, function(x) add_peak_info(x, gam = gam, lambda = lambda,constraint, estimate_calcium, var, ESP))
peaks_data <- lapply(cell_split, function(x) if(length(x$peak_frames)[[1]] != 0) {x[x$time_frame %in% x$peak_frames[[1]]]} )
data <- do.call(rbind, cell_split)
peaks_data <- do.call(rbind, peaks_data)
if(length(peaks_data$Cell_id) != 0) {
# For each spike, get it and the 21 lines that follow it then find the max peak
# and only keep that line
dt <- subset_spike_frames(norm_data,peaks_data)
dt <- dt[, Max_by_20 := max(smooth_z, na.rm = TRUE), by = blocs]
dt <- dt[Max_by_20 ==  smooth_z]
peaks_data$Max_peak_frame <- dt$time_frame
peaks_data$max_peak_smooth_z <- dt$smooth_z
}
# Remove NAs and spikes with a max peak below threshold
peaks_data <- peaks_data[!is.na(max_peak_smooth_z) & max_peak_smooth_z >= threshold]
if(is.null(peaks_data) == FALSE) {
peaks_data <- dplyr::rename(peaks_data,  "spike_stimulus" = "stimulus", "spike_frame" = "time_frame", "spike_stimulation" = "Stimulation",
"spike_smooth_z" = "smooth_z", "spike_first_derivative" = "first_derivative" )
peaks_data <- unique(peaks_data[,c("Cell_id", "spike_frame", "spike_stimulus",
"spike_smooth_z", "Mean_Grey", "gam_detrended", "Max_peak_frame", "max_peak_smooth_z" )])
}
return(list(peaks_data, data))
}
test_deconvolve <- deconvolve_vec(test_VNO_norm_1Hz, lambda = 10000, gam = 0.90, constraint =T, threshold = 3)
#' subset_spike_frames
#'
#' @param dt1
#' @param dt2
#'
#' @return
#' @export
#'
#' @examples
subset_spike_frames <- function(dt1,dt2){
# Retrieve indices of lines where a spike occurred in dt1
setkey(dt1, Cell_id, time_frame)
setkey(dt2, Cell_id, time_frame)
match_indices <- dt1[dt2, which = TRUE]
# create a border 20 lines later (for each spike)
end <- match_indices + 20L
match <- match_indices[, id := seq(1,length(match_indices$Cell_id))]
dt1 <- dt1[, id := seq(1,length(dt1$Cell_id))]
# Extract the line + the 20 following each spike
res <- dt1[.(id = unlist(Map(':', match_indices, end))), on = "id"]
# Add a grouping variable "blocs" to then compute the max on each of these parts
res <- res[, blocs := rep(1:(length(res$Cell_id)/21), each = 21)]
return(res)
}
#' @param constraint
#' @param estimate_calcium
#' @param var
#' @param ESP
#' @param threshold
#'
#' @return
#' @export
#'
#' @examples
deconvolve_vec <- function(norm_data, gam = 0.95, lambda = 1, constraint = T, estimate_calcium = T, var = "gam_detrended", ESP = 0.0001,
threshold = 3) {
cells <- unique(norm_data$Cell_id)
cell_split <- split(norm_data, norm_data$Cell_id)
cell_split <- lapply(cell_split, function(x) add_peak_info(x, gam = gam, lambda = lambda,constraint, estimate_calcium, var, ESP))
peaks_data <- lapply(cell_split, function(x) if(length(x$peak_frames)[[1]] != 0) {x[x$time_frame %in% x$peak_frames[[1]]]} )
data <- do.call(rbind, cell_split)
peaks_data <- do.call(rbind, peaks_data)
if(length(peaks_data$Cell_id) != 0) {
# For each spike, get it and the 21 lines that follow it then find the max peak
# and only keep that line
dt <- subset_spike_frames(norm_data,peaks_data)
dt <- dt[, Max_by_20 := max(smooth_z, na.rm = TRUE), by = blocs]
dt <- dt[Max_by_20 ==  smooth_z]
peaks_data$Max_peak_frame <- dt$time_frame
peaks_data$max_peak_smooth_z <- dt$smooth_z
}
# Remove NAs and spikes with a max peak below threshold
peaks_data <- peaks_data[!is.na(max_peak_smooth_z) & max_peak_smooth_z >= threshold]
if(is.null(peaks_data) == FALSE) {
peaks_data <- dplyr::rename(peaks_data,  "spike_stimulus" = "stimulus", "spike_frame" = "time_frame", "spike_stimulation" = "Stimulation",
"spike_smooth_z" = "smooth_z", "spike_first_derivative" = "first_derivative" )
peaks_data <- unique(peaks_data[,c("Cell_id", "spike_frame", "spike_stimulus",
"spike_smooth_z", "Mean_Grey", "gam_detrended", "Max_peak_frame", "max_peak_smooth_z" )])
}
return(list(peaks_data, data))
}
test_deconvolve <- deconvolve_vec(test_VNO_norm_1Hz, lambda = 10000, gam = 0.90, constraint =T, threshold = 3)
#' subset_spike_frames
#'
#' @param dt1
#' @param dt2
#'
#' @return
#' @export
#'
#' @examples
subset_spike_frames <- function(dt1,dt2){
# Retrieve indices of lines where a spike occurred in dt1
setkey(dt1, Cell_id, time_frame)
setkey(dt2, Cell_id, time_frame)
match_indices <- dt1[dt2, which = TRUE]
# create a border 20 lines later (for each spike)
end <- match_indices + 20L
print(match_indices)
print(str(match_indices))
match <- match_indices[, id := seq(1,length(match_indices$Cell_id))]
dt1 <- dt1[, id := seq(1,length(dt1$Cell_id))]
# Extract the line + the 20 following each spike
res <- dt1[.(id = unlist(Map(':', match_indices, end))), on = "id"]
# Add a grouping variable "blocs" to then compute the max on each of these parts
res <- res[, blocs := rep(1:(length(res$Cell_id)/21), each = 21)]
return(res)
}
#' @param constraint
#' @param estimate_calcium
#' @param var
#' @param ESP
#' @param threshold
#'
#' @return
#' @export
#'
#' @examples
deconvolve_vec <- function(norm_data, gam = 0.95, lambda = 1, constraint = T, estimate_calcium = T, var = "gam_detrended", ESP = 0.0001,
threshold = 3) {
cells <- unique(norm_data$Cell_id)
cell_split <- split(norm_data, norm_data$Cell_id)
cell_split <- lapply(cell_split, function(x) add_peak_info(x, gam = gam, lambda = lambda,constraint, estimate_calcium, var, ESP))
peaks_data <- lapply(cell_split, function(x) if(length(x$peak_frames)[[1]] != 0) {x[x$time_frame %in% x$peak_frames[[1]]]} )
data <- do.call(rbind, cell_split)
peaks_data <- do.call(rbind, peaks_data)
if(length(peaks_data$Cell_id) != 0) {
# For each spike, get it and the 21 lines that follow it then find the max peak
# and only keep that line
dt <- subset_spike_frames(norm_data,peaks_data)
dt <- dt[, Max_by_20 := max(smooth_z, na.rm = TRUE), by = blocs]
dt <- dt[Max_by_20 ==  smooth_z]
peaks_data$Max_peak_frame <- dt$time_frame
peaks_data$max_peak_smooth_z <- dt$smooth_z
}
# Remove NAs and spikes with a max peak below threshold
peaks_data <- peaks_data[!is.na(max_peak_smooth_z) & max_peak_smooth_z >= threshold]
if(is.null(peaks_data) == FALSE) {
peaks_data <- dplyr::rename(peaks_data,  "spike_stimulus" = "stimulus", "spike_frame" = "time_frame", "spike_stimulation" = "Stimulation",
"spike_smooth_z" = "smooth_z", "spike_first_derivative" = "first_derivative" )
peaks_data <- unique(peaks_data[,c("Cell_id", "spike_frame", "spike_stimulus",
"spike_smooth_z", "Mean_Grey", "gam_detrended", "Max_peak_frame", "max_peak_smooth_z" )])
}
return(list(peaks_data, data))
}
test_deconvolve <- deconvolve_vec(test_VNO_norm_1Hz, lambda = 10000, gam = 0.90, constraint =T, threshold = 3)
#' subset_spike_frames
#'
#' @param dt1
#' @param dt2
#'
#' @return
#' @export
#'
#' @examples
subset_spike_frames <- function(dt1,dt2){
# Retrieve indices of lines where a spike occurred in dt1
setkey(dt1, Cell_id, time_frame)
setkey(dt2, Cell_id, time_frame)
match_indices <- dt1[dt2, which = TRUE]
# create a border 20 lines later (for each spike)
end <- match_indices + 20L
#match <- match_indices[, id := seq(1,length(match_indices$Cell_id))]
dt1 <- dt1[, id := seq(1,length(dt1$Cell_id))]
# Extract the line + the 20 following each spike
res <- dt1[.(id = unlist(Map(':', match_indices, end))), on = "id"]
# Add a grouping variable "blocs" to then compute the max on each of these parts
res <- res[, blocs := rep(1:(length(res$Cell_id)/21), each = 21)]
return(res)
}
#' @param constraint
#' @param estimate_calcium
#' @param var
#' @param ESP
#' @param threshold
#'
#' @return
#' @export
#'
#' @examples
deconvolve_vec <- function(norm_data, gam = 0.95, lambda = 1, constraint = T, estimate_calcium = T, var = "gam_detrended", ESP = 0.0001,
threshold = 3) {
cells <- unique(norm_data$Cell_id)
cell_split <- split(norm_data, norm_data$Cell_id)
cell_split <- lapply(cell_split, function(x) add_peak_info(x, gam = gam, lambda = lambda,constraint, estimate_calcium, var, ESP))
peaks_data <- lapply(cell_split, function(x) if(length(x$peak_frames)[[1]] != 0) {x[x$time_frame %in% x$peak_frames[[1]]]} )
data <- do.call(rbind, cell_split)
peaks_data <- do.call(rbind, peaks_data)
if(length(peaks_data$Cell_id) != 0) {
# For each spike, get it and the 21 lines that follow it then find the max peak
# and only keep that line
dt <- subset_spike_frames(norm_data,peaks_data)
dt <- dt[, Max_by_20 := max(smooth_z, na.rm = TRUE), by = blocs]
dt <- dt[Max_by_20 ==  smooth_z]
peaks_data$Max_peak_frame <- dt$time_frame
peaks_data$max_peak_smooth_z <- dt$smooth_z
}
# Remove NAs and spikes with a max peak below threshold
peaks_data <- peaks_data[!is.na(max_peak_smooth_z) & max_peak_smooth_z >= threshold]
if(is.null(peaks_data) == FALSE) {
peaks_data <- dplyr::rename(peaks_data,  "spike_stimulus" = "stimulus", "spike_frame" = "time_frame", "spike_stimulation" = "Stimulation",
"spike_smooth_z" = "smooth_z", "spike_first_derivative" = "first_derivative" )
peaks_data <- unique(peaks_data[,c("Cell_id", "spike_frame", "spike_stimulus",
"spike_smooth_z", "Mean_Grey", "gam_detrended", "Max_peak_frame", "max_peak_smooth_z" )])
}
return(list(peaks_data, data))
}
test_deconvolve <- deconvolve_vec(test_VNO_norm_1Hz, lambda = 10000, gam = 0.90, constraint =T, threshold = 3)
test_deconvolve
library(calipR)
test_deconvolve <- deconvolve(test_VNO_norm_1Hz, lambda = 1, gam = 0.90, constraint =T, threshold = 3)
test_deconvolve
test_VNO_best_1Hz <- keep_best_peaks(test_deconvolve)
test_borders_1Hz <- find_borders(test_VNO_best_1Hz, 150)
test_deconvolve <- deconvolve_vec(test_VNO_norm_1Hz, lambda = 10000, gam = 0.90, constraint =T, threshold = 3)
test_deconvolve <- deconvolve(test_VNO_norm_1Hz, lambda = 10000, gam = 0.90, constraint =T, threshold = 3)
test_VNO_best_1Hz <- keep_best_peaks(test_deconvolve)
test_borders_1Hz <- find_borders(test_VNO_best_1Hz, 150)
simple_cell_plot(test_norm_1Hz, var = "Mean_Grey", cell = "aaad", line = TRUE)
simple_cell_plot(test_VNO_norm_1Hz, var = "Mean_Grey", cell = "aaad", line = TRUE)
simple_cell_plot(test_VNO_norm_1Hz, var = "Mean_Grey", cell = "A1aad", line = TRUE)
View(test_VNO_norm_1Hz)
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "A1aad", line = TRUE)
test_VNO_back_1Hz
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "A1aad", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1aad", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1aap", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1ayu", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1azq", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1aag", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1aae", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1abq", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1abe", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1abd", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1abu", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1aru", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1aat", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1aro", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1aax", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "Mean_Grey", cell = "1aro", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "gam_detrended", cell = "1aap", line = "gam")
simple_cell_plot(test_VNO_back_1Hz, var = "gam_detrended", cell = "1aap", line = FALSE)
simple_cell_plot(test_VNO_back_1Hz, var = "gam_detrended", cell = "1ayu", line = FALSE)
simple_cell_plot(test_VNO_back_1Hz, var = "gam_detrended", cell = "1azq", line = FALSE)
simple_cell_plot(test_VNO_back_1Hz, var = "gam_detrended", cell = "1aad", line = FALSE)
test_VNO_back_1Hz
test_VNO_norm_1Hz
simple_cell_plot(test_VNO_norm_1Hz, var = "z_score", cell = "1aad", line = FALSE)
simple_cell_plot(test_VNO_norm_1Hz, var = "z_score", cell = "1azq", line = FALSE)
simple_cell_plot(test_VNO_norm_1Hz, var = "z_score", cell = "1aap", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "deconvolved_trace", cell = "1aap", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "deconvolved_trace", cell = "1aad", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "deconvolved_trace", cell = "1aae", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "Mean_Grey", cell = "1aae", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "Mean_Grey", cell = "1aag", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "deconvolved_trace", cell = "1aag", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "deconvolved_trace", cell = "1aah", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "deconvolved_trace", cell = "1aai", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "Mean_Grey", cell = "1aai", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "Mean_Grey", cell = "1aaj", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "Mean_Grey", cell = "1aak", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "Mean_Grey", cell = "1aal", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "Mean_Grey", cell = "1aam", line = FALSE)
simple_cell_plot(test_deconvolve[[2]], var = "deconvolved_trace", cell = "1aam", line = FALSE)
#### Ici les classifications valent pour le CV3 (fichier de thiago 1Hz fait avec une baseline et un pup wash)
# Seuil pour classifier =  >= 3 ecarts types + visuellement apparence d'une réponse
pos_list <- c( "aaad","aaae","aaag","aaak","aaam","aaap","aaax","aabc","aabl","aabn",
"aacb","aacg","aaci","aacs","aacu","aacv","aacw","aada","aadb","aadf",
"aadg","aadh","aadi","aadj","aagf" ,"aagc","aagg","aagm","aagv","aahf",
"aahp","aahu","aahv","aahw", "aaft","aafq", "aafo", "aafj", "aafh", "aaff",
"aaev","aafe", "aafb","aaez", "aaer", "aaef","aaec","aalp","aalk","aali","aald","aakx","aakq",
"aakn","aake","aaju","aajp","aajk","aajg","aaiv","aaiu","aaiq","aail","aapq",
"aapn","aapf","aapd","aaov","aaol","aaod","aaoc","aanv","aanu","aant","aanr","aano",
"aann","aank","aanj","aanc","aana","aamg","aamc","aamb","aatr","aatf",
"aatc","aasq","aasl","aasa","aary","aarv","aarp","aaqw","aaqs","aaqn","aaqh",
"aaqd","aaqc", "aaxu", "aaxt", "aaxr", "aaxp","aaxi", "aaxd", "aaxa", "aawu","aawk",
"aawb","aawa", "aavz", "aavy", "aavx", "aavw", "aavt","aavq", "aavp","aavo", "aavl",
"aavk","aave", "aauu", "aauj", "abbu", "abbs", "abbr", "abbq", "abbp",
"abbj", "abbi", "abbh", "abbg", "abax", "abas", "abaq", "abaj","abab","aazy",
"aazu", "aazs","aazj", "aazh", "aazf", "aayv", "aayo","aayj", "aayg","abcs",
"abcq","abcp","abco","abcn","abci","abcg","abcf","abdg","abdf","abdd","aacl", "aajn","aahc"
)
neg_list <- c( "aaaa","aaab","aaac","aaaf","aaah","aaai", "aaaj","aaal","aaan","aaao",
"aaaq","aaar","aaas","aaat","aaau","aaav","aaaw","aaay","aaaz","aaba","aabb",
"aabd","aabe","aabf","aabg","aabh","aabi","aabj","aabk","aabo",
"aabp","aabq","aabr","aabs","aabt","aabu","aabv","aabw","aabx","aaby",
"aaca","aacc","aacd","aace","aach","aacj","aack","aacm","aacn",
"aaco","aacp","aacq","aacr","aacx","aacy","aacz","aadc","aadd","aade", "aadk","aadl",
"aadm","aadn","aado","aadp","aadq","aadr","aads","aadt","aadu","aadv",
"aadw", "aadx","aady","aadz","aafu","aafw","aafx","aafy","aafz","aaga","aagb","aagd","aage",
"aagh","aagi","aagj","aagl","aagn","aagp","aagq","aagr","aags","aagt","aagu","aagw","aagx","aagy",
"aagz","aaha","aahb","aahd","aahe","aahg","aahh","aahj","aahk","aahl","aahn","aaho","aahs","aaht",
"aafs", "aafr", "aafp","aafn", "aafm", "aafl","aafk", "aafi", "aafd", "aafc", "aafa","aaey",
"aaex","aaew", "aaeu", "aaet", "aaes", "aaeq", "aaep", "aaeo", "aaen", "aaem", "aael", "aaek",
"aaej", "aaei","aaeh","aaeg","aaee","aaed","aaeb","aaea", "aalt","aals","aalr","aalq",
"aalo", "aaln","aalm","aall","aalj","aalh","aalg","aalf","aale","aalc","aalb","aala","aakz",
"aaky","aakw","aakv","aaku","aakt","aaks","aakr","aakp","aako","aakm","aakl","aakk",
"aakj","aaki","aakh","aakg","aakf","aakd","aakc","aakb","aaka","aajz","aajy","aajx",
"aajw","aajv","aajt","aajs","aajr","aajq","aajo","aajm","aajl","aajj","aaji","aajh",
"aajf","aaje", "aajd","aajc","aajb","aaja","aaiz","aaiy","aaix","aaiw","aait","aais","aair",
"aaip","aaio","aain","aaim","aaik","aaij","aaii","aaih","aaig","aaif","aaie","aaic","aaib",
"aaia","aahz","aahy","aahx", "aaps","aapr","aapp","aapo","aapm","aapl","aapk","aapj",
"aapi","aaph","aapg","aape","aapc","aapb","aaoz","aaoy","aaox","aaow","aaou",
"aaot","aaos","aaor","aaoq","aaoo","aaon","aaom","aaok","aaoj","aaoi","aaoh","aaog",
"aaof","aaoe","aaob","aaoa","aanz","aany","aanx","aanw","aans","aanq","aanp","aanm",
"aanl","aani","aanh","aang","aanf","aane","aand","aanb","aamz","aamy","aamx","aamw",
"aamu","aams","aamr","aamq","aamp","aamo","aamn","aamm","aaml","aamk","aamj","aami",
"aamh","aamf","aame","aamd","aama","aalz","aaly","aalx","aalw","aalv","aalu","aatv","aatt",
"aats","aatq","aatp","aato","aatn","aatm","aatl","aatk","aatj","aati","aath","aatg","aatd",
"aatb","aata","aasz","aasy","aasx","aasw","aasv","aasu","aast","aass","aasr","aasp","aaso",
"aasm","aask","aasj","aasi","aash","aasg","aasf","aase","aasd","aasc","aasb","aarx","aarw",
"aaru","aart","aarr","aarq","aaro","aarn", "aarl","aark","aarj","aari","aarh","aarg","aarf",
"aare","aard","aarc","aarb","aara","aaqz","aaqy","aaqx","aaqv","aaqu","aaqt","aaqr","aaqo",
"aaqm","aaql","aaqk","aaqj","aaqi","aaqg","aaqf","aaqe","aaqb","aaqa","aapz","aapy","aapx",
"aapw","aapv","aapu","aapt", "aaxs", "aaxq", "aaxo", "aaxn", "aaxm", "aaxl", "aaxk", "aaxj",
"aaxh", "aaxg", "aaxf", "aaxe", "aaxc", "aaxb", "aawz", "aawy", "aawx", "aaww", "aawv",
"aawt", "aaws", "aawr", "aawq", "aawp", "aawo", "aawn", "aawm", "aawl", "aawj", "aawi",
"aawh", "aawg", "aawf", "aawe", "aawc", "aavv", "aavu", "aavs", "aavr", "aavn",
"aavm","aavj", "aavi", "aavh", "aavg", "aavf", "aavd", "aavc", "aavb", "aava", "aauz",
"aauy", "aaux", "aauw", "aauv", "aaut", "aaus", "aaur", "aauq", "aaup", "aauo", "aaun",
"aaum", "aaul", "aauk", "aaui", "aauh", "aaug", "aauf", "aaue", "aaud", "aauc","aaub",
"aaty", "aatx", "abbv", "abbt", "abbo", "abbn", "abbm", "abbl", "abbk", "abbf",
"abbe", "abbd", "abbc", "abbb", "abba", "abaz", "abay", "abaw", "abav", "abau", "abat",
"abar", "abap","abao","aban","abam","abal","abak","abai","abah","abag","abaf","abae",
"abad","abac","abaa", "aazv","aazt","aazq", "aazp", "aazm","aazl","aazk","aazi", "aazd",
"aazc","aazb","aaza", "aayz","aayy", "aayw", "aayu", "aayt", "aays", "aayr", "aayq",
"aayp", "aayn", "aaym","aayl","aayk","aayi","aayh","aayf","aaye","aayd","aayc","aaya",
"aaxz","aaxy","aaxx","aaxw","aaxv", "abcz", "abcy", "abcx","abcw","abcv","abcu",
"abct","abcr","abcm","abck","abcj","abch","abce","abcd","abcc","abcb","abbz","abby",
"abbx","abdi","abdh","abdc", "abdb","abda")
# Pour la baseline, étant donné que les écart types sont biaisés, je prends également n critère subjectif visuel pour les catégoriser comme réponse
base_resp <- c("aabz","aacf","aact", "aagk","aago","aahq","ahhr","aajn","aapa", "aarz", "aatz", "aazo",
"aazn", "aazg", "aayx", "abbw", "abde", "aabm", "aabz")
base_resp_entre_deux <- c("abcl")
resp_entre_deux <- c("aazx", "abca")
library(calipR)
test_VNO_clean_1Hz
test_VNO_clean_1Hz$Cell_id_bis <- test_VNO_clean_1Hz$Cell_id
str_replace_all(test_VNO_clean_1Hz$Cell_id_bis, "1", "a" )
test_VNO_clean_1Hz$Cell_id_bis  <- str_replace_all(test_VNO_clean_1Hz$Cell_id_bis, "1", "a" )
test_VNO_clean_1Hz
test_VNO_back_1Hz <- backEstimate(test_VNO_clean_1Hz, method = "gam")
test_VNO_norm_1Hz <- norm_df(test_VNO_back_1Hz, var = "gam", width = 10)
test_deconvolve <- deconvolve(test_VNO_norm_1Hz, lambda = 1000, gam = 0.90, constraint =T, threshold = 3)
test_deconvolve[[1]]
cal_resp <- unique(test_deconvolve[[1]]$Cell_id)
cal_resp
cal_non_resp <- length(unique(test_VNO_clean_1Hz$Cell_id)) - length(cal_resp)
cal_non_resp
cal_pos <- data.frame(pos_list)
cal_pos$cells_kept <- pos_list %in% cal_resp
false_neg_cal <- data.table::setDT(cal_pos)[cal_pos$cells_kept == FALSE]
n_false_neg_cal <- length(unique(false_neg_cal$pos_list))
true_neg_cal <- cal_non_resp - n_false_neg_cal
cal_pos
false_neg_cal
n_false_neg_cal
true_neg_cal
pos_list
cal_pos
cal_pos <- data.frame(pos_list)
cal_resp
cal_resp <- unique(test_deconvolve[[1]]$Cell_id_bis)
cal_non_resp <- length(unique(test_VNO_clean_1Hz$Cell_id)) - length(cal_resp)
cal_pos <- data.frame(pos_list)
cal_pos$cells_kept <- pos_list %in% cal_resp
cal_pos
cal_resp <- unique(test_deconvolve[[1]]$Cell_id_bis)
cal_non_resp <- length(unique(test_VNO_clean_1Hz$Cell_id_bis)) - length(cal_resp)
cal_pos <- data.frame(pos_list)
cal_resp
test_deconvolve$Cell_id_bis  <- str_replace_all(test_deconvolve$Cell_id_bis, "1", "a" )
cal_resp <- unique(test_deconvolve[[1]]$Cell_id_bis)
cal_resp
test_VNO_clean_1Hz$Cell_id_bis  <- str_replace_all(test_VNO_clean_1Hz$Cell_id_bis, "1", "a" )
test_VNO_back_1Hz <- backEstimate(test_VNO_clean_1Hz, method = "gam")
test_VNO_norm_1Hz <- norm_df(test_VNO_back_1Hz, var = "gam", width = 10)
test_deconvolve <- deconvolve(test_VNO_norm_1Hz, lambda = 1000, gam = 0.90, constraint =T, threshold = 3)
test_deconvolve[[1]]$Cell_id_bis  <- str_replace_all(test_deconvolve[[1]]$Cell_id_bis, "1", "a" )
cal_resp <- unique(test_deconvolve[[1]]$Cell_id_bis)
cal_resp
test_deconvolve
test_deconvolve[[1]]$Cell_id_bis  <- str_replace_all(test_deconvolve[[1]]$Cell_id, "1", "a" )
cal_resp <- unique(test_deconvolve[[1]]$Cell_id_bis)
cal_resp
cal_non_resp <- length(unique(test_VNO_clean_1Hz$Cell_id_bis)) - length(cal_resp)
cal_pos <- data.frame(pos_list)
cal_pos$cells_kept <- pos_list %in% cal_resp
false_neg_cal <- data.table::setDT(cal_pos)[cal_pos$cells_kept == FALSE]
n_false_neg_cal <- length(unique(false_neg_cal$pos_list))
true_neg_cal <- cal_non_resp - n_false_neg_cal
cal_pos
false_neg_cal
n_false_neg_cal
true_neg_cal
### faux positifs
cal_false_pos <- data.frame(cal_resp)
cal_false_pos$false_pos <- cal_resp %in% pos_list
false_pos_cal <- data.table::setDT(cal_false_pos)[cal_false_pos$false_pos == FALSE,]$cal_resp
n_false_pos_cal <- length(unique(false_pos_cal))
true_pos_cal <- length(cal_resp) - n_false_pos_cal
n_false_pos_cal
true_pos_cal
n_false_pos_cal_3 <- length(unique(false_pos_cal))
true_pos_cal_3 <- length(cal_resp) - n_false_pos_cal
n_false_neg_cal_3 <- length(unique(false_neg_cal$pos_list))
true_neg_cal_3 <- cal_non_resp - n_false_neg_cal
n_false_neg_cal_3
true_neg_cal_3
n_false_pos_cal_3
true_pos_cal_3
test_deconvolve <- deconvolve(test_VNO_norm_1Hz, lambda = 1000, gam = 0.90, constraint =T, threshold = 2.5)
cal_resp <- unique(test_deconvolve[[1]]$Cell_id_bis)
cal_non_resp <- length(unique(test_VNO_clean_1Hz$Cell_id_bis)) - length(cal_resp)
cal_pos <- data.frame(pos_list)
cal_pos$cells_kept <- pos_list %in% cal_resp
false_neg_cal <- data.table::setDT(cal_pos)[cal_pos$cells_kept == FALSE]
n_false_neg_cal_2_5 <- length(unique(false_neg_cal$pos_list))
true_neg_cal_2_5 <- cal_non_resp - n_false_neg_cal
n_false_neg_cal_2_5
true_neg_cal_2_5
test_deconvolve[[1]]$Cell_id_bis  <- str_replace_all(test_deconvolve[[1]]$Cell_id, "1", "a" )
cal_resp <- unique(test_deconvolve[[1]]$Cell_id_bis)
cal_non_resp <- length(unique(test_VNO_clean_1Hz$Cell_id_bis)) - length(cal_resp)
cal_pos <- data.frame(pos_list)
cal_pos$cells_kept <- pos_list %in% cal_resp
false_neg_cal <- data.table::setDT(cal_pos)[cal_pos$cells_kept == FALSE]
n_false_neg_cal_2_5 <- length(unique(false_neg_cal$pos_list))
true_neg_cal_2_5 <- cal_non_resp - n_false_neg_cal
n_false_neg_cal_2_5
true_neg_cal_2_5
### faux positifs
cal_false_pos <- data.frame(cal_resp)
cal_false_pos$false_pos <- cal_resp %in% pos_list
false_pos_cal <- data.table::setDT(cal_false_pos)[cal_false_pos$false_pos == FALSE,]$cal_resp
n_false_pos_cal_2_5 <- length(unique(false_pos_cal))
true_pos_cal_2_5 <- length(cal_resp) - n_false_pos_cal
n_false_pos_cal_2_5
true_pos_cal_2_5
true_pos_cal_3
n_false_pos_cal_2_5
true_pos_cal_2_5
false_pos_cal
lapply(false_pos_cal, function(x) simple_cell_plot(data = test_VNO_norm_1Hz, cell = x, var = "Mean_Grey", line = "gam"))
false_pos_cal
test_VNO_norm_1Hz
test_VNO_norm_1Hz$Cell_id <- test_VNO_clean_1Hz$Cell_id_bis
lapply(false_pos_cal, function(x) simple_cell_plot(data = test_VNO_norm_1Hz, cell = x, var = "Mean_Grey", line = "gam"))
# Pour la baseline, étant donné que les écart types sont biaisés, je prends également n critère subjectif visuel pour les catégoriser comme réponse
base_resp <- c("aabz","aacf","aact", "aagk","aago","aahq","ahhr","aajn","aapa", "aarz", "aatz", "aazo",
"aazn", "aazg", "aayx", "abbw", "abde", "aabm", "aabz")
# Certains des faux positifs répondent en fait à la baseline, donc il faut retirer
# ceux là aussi :
false_pos_cal %in% base_resp
# Certains des faux positifs répondent en fait à la baseline, donc il faut retirer
# ceux là aussi :
sum(false_pos_cal %in% base_resp)
# Certains des faux positifs répondent en fait à la baseline, donc il faut retirer
# ceux là aussi :
n_base_resp <- sum(false_pos_cal %in% base_resp)
n_false_pos_base_corr <- n_false_pos_cal_2_5 - n_base_resp
n_false_pos_base_corr
true_pos_cal_2_5_base_corr <- true_pos_cal_2_5 + n_base_resp
true_pos_cal_2_5_base_corr
n_false_neg_cal_2_5
length(pos_list)
sessionInfo()
library(RTools)
library(rtools)
library(Rtools)
library(installr)
0.065*60
0.065*0.60
