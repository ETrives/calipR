shinydashboard::tabItems(
shinydashboard::tabItem("des",
shiny::fluidRow(
shiny::img(src = "logo/calipR_logo.png",
style = "border: 1px;
color: white;
position: absolute;
top : 100px;
left: 300px;
right: 0;
margin: 0 auto;
max-width: 250px;"), shiny::div(style = "height:1000px;")),
shiny::fluidRow(
shiny::HTML( "<center> <p style = 'font-size: 20px; word-wrap: break-word;
width: 1000px; align: justify; color: black; padding-top: 50px;
position: absolute;
top: 400px;
left: 250px;
right: 0;
margin: 0 auto;
max-width: 600px;'> <b> calipR </b> is an open source software designed to facilitate calcium imaging data analysis.
It is fully written in the R programming language.
With this Graphical User Interface (GUI) you can analyze your data
without any programming skills.<br> <br>
Two workflows are available: one that allows you to automatize
ROIs detection with the Trackmate imageJ plugin and another
one that takes the output from manual ROI detection in ImageJ.
To start with your first analysis you can go on to the Tutorial page.</p> </center>"),
),
shiny::fluidRow(shiny::tags$br()),
shiny::fluidRow(shiny::tags$br()),
shiny::fluidRow(shiny::tags$br()),
),
shinydashboard::tabItem("ana", shiny::fluidRow(shiny::div(style = "height:1000px;"))),
shinydashboard::tabItem("tuto", shiny::fluidRow(shiny::div(style = "height:1000px;"))),
shinydashboard::tabItem("prep",
shiny::tags$style(shiny::HTML("
.box.box-solid.box-primary>.box-header {
color:#fff;
background:#5499c7
}
.box.box-solid.box-primary{
border-bottom-color:#5499c7  ;
border-left-color:#5499c7  ;
border-right-color:#5499c7  ;
border-top-color:#5499c7  ;
}
.box.box-primary>.box-header {
color:#000000;
background:#fff
}
.box.box-primary{
border-bottom-color:#5499c7  ;
border-left-color:#5499c7  ;
border-right-color:#5499c7  ;
border-top-color:#5499c7  ;
}
")),
shiny::fluidRow(class = "myRow1",
shiny::column(12,
shinydashboard::box(title = "Dataset Prepared", width = 12, solidHeader = TRUE, status = "primary", collapsible = T,
DT::dataTableOutput("df_sql")),
shiny::div(style = "height:1000px;")))),
shinydashboard::tabItem("viz",
shiny::fluidRow(
shinydashboard::box(title = "Plotting Cells", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("cell", label = NULL, placeholder = "Enter the name of the cell you want to plot"),
shiny::actionButton("cell_click", "Plot Cell", align = "center"),
shiny::plotOutput(outputId = "plot_cell")), shiny::div(style = "height:1000px"))),
shinydashboard::tabItem("opt",
shiny::fluidRow(
shinydashboard::box(title = "Optimize Parameters", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("peak_thresh", label = "Peak Threshold", placeholder = "Enter the peak threshold you want to try (z score)"),
shiny::textInput("rise_range", label = "Range", placeholder = "Enter the range taken to find a peak start (integer between 5 and 60)"),
shiny::textInput("lambda", label = "Lambda", placeholder = "Enter the Lambda parameter for the Deconvolution (integer)"),
shiny::textInput("gam", label = "Gam", placeholder = "Enter the Gam parameter for the Deconvolution (double between 0-1)"),
shiny::textInput("n_cells", label = "Number of cells", placeholder = "Enter the number of cells you want to run the stimulation on"),
shiny::checkboxInput("false_pos", label = "Estimate False Positives"),
shiny::checkboxInput("show_peak", label = "Show Peaks"),
shiny::uiOutput('responders'),
shiny::uiOutput('non_responders'),
shiny::actionButton("sim", "Simulate Analysis", align = "center"),
shiny::actionButton("plot_responders", "Plot Responder", align = "center"),
shiny::actionButton("plot_non_responders", "Plot Non Responder", align = "center")),
shinydashboard::box(title = "Try other parameters on a given cell", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("cell_opt", label = "Cell", placeholder = "On which cell do you want to try new parameters ?"),
shiny::textInput("peak_thresh_bis", label = "Threshold", placeholder = "Enter the peak threshold you want to try (z score)"),
shiny::textInput("rise_range_bis", label = "Range", placeholder = "Enter the range taken to find a peak start (integer between 5 and 60)"),
shiny::textInput("lambda_bis", label = "Lambda", placeholder = "Enter the Lambda parameter for the Deconvolution (integer)"),
shiny::textInput("gam_bis", label = "Gam", placeholder = "Enter the Gam parameter for the Deconvolution (double between 0-1)"),
shiny::checkboxInput("false_pos_bis", label = "Estimate False Positives"),
shiny::checkboxInput("show_peak_bis", label = "Show Peaks"),
shiny::actionButton("sim_bis", "Simulate Analysis", align = "center"),
shiny::actionButton("plot_simulation_bis", "Plot Cell", align = "center"))),
shiny::fluidRow(
shinydashboard::box(title = "Plot Window", width = 6, solidHeader = TRUE, status = "primary",
shiny::plotOutput(outputId = "plot_cell_sim")),
shinydashboard::box(title = "Plot Window", width = 6, solidHeader = TRUE, status = "primary",
shiny::plotOutput(outputId = "plot_cell_sim_bis"))),
shiny::fluidRow(
shinydashboard::box(title = "Statistics", width = 6, solidHeader = TRUE, status = "primary",
DT::dataTableOutput("stats_opt")))),
shinydashboard::tabItem("ana_full",
shiny::fluidRow(
shinydashboard::box(title = "Description of Responses", width = 12, solidHeader = TRUE, status = "primary",
shinycssloaders::withSpinner(DT::dataTableOutput("resp_count"), type = 6),
DT::dataTableOutput("resp_group_stim"),
DT::dataTableOutput("peaks_by_class"),
DT::dataTableOutput("overall_q"),
DT::dataTableOutput("post_hoc_mcnemar")
)),
shiny::fluidRow(
shinydashboard::box(title = "Dual Proportions", width = 12, solidHeader = TRUE, status = "primary",
shiny::uiOutput("stim_list_1"),
shiny::uiOutput("stim_list_2"),
shiny::actionButton("dual_button", "Compute Dual Proportions", align = "center" ),
shiny::br(),
shiny::br(),
DT::dataTableOutput("dual_prop")),shiny::div(style = "height:1000px;"))),
shinydashboard::tabItem("viz_res",
shiny::fluidRow(
shinydashboard::box(title = "Plotting Cells", width = 12, solidHeader = TRUE, status = "primary",
shiny::selectInput(inputId = "x", label = NULL, list("Group" = "Group", "Coverslip" = "Coverslip", "Stimulus" = "Stimulus")),
shiny::selectInput(inputId = "y", label = NULL, list("Proportion" = "Proportion", "Responses" = "Responses")),
shiny::selectInput(inputId = "z", label = NULL, list("Group" = "Group", "Coverslip" = "Coverslip", "Stimulus" = "Stimulus")),
plotly::plotlyOutput(outputId = "viz")),shiny::div(style = "height:1000px;")))
)))
server <- function(input, output){
sqlitePath <- getwd()
folder <- shiny::reactive({
if(is.null(input$folder)) {return()}
else{
folder <- input$folder
folder
}
})
stim_numb <- shiny::reactive({
if(is.null(input$stim_num)) {return()}
else{
stim_numb <- as.numeric(input$stim_num)
stim_numb
}
})
df_final <- shiny::eventReactive(input$launch, {
df <- calipR::prepareData(folder(), stim_numb(), 0.25, compare_groups = TRUE)
calipR::saveData(df, "db_cq.sqlite", "df_full")
df
})
output$df_sql <- DT::renderDataTable({
if(is.null(df_final())) {return()}
else{
df <- calipR::loading100("db_cq.sqlite", "df_full")
df <- DT::datatable(df)
df
}
})
df_plot <- shiny::eventReactive(input$cell_click, {
df <- calipR::get_cell(input$cell, "db_cq.sqlite", "df_full")
df
})
output$plot_cell <- shiny::renderPlot({
p <- calipR::cell_plot_shiny(df_plot())
p
})
res_sim <- shiny::reactiveValues(res = NULL)
shiny::observeEvent(input$sim, {
print("Simulation started")
df_sub <- calipR::get_sub_df("db_cq.sqlite", "df_full", input$n_cells)
res_sim$res <- calipR::downstream_analysis(df_sub, threshold = input$peak_thresh,
borders_range = input$rise_range, lambda = input$lambda, gam = input$gam,
false_pos = input$false_pos)
})
if(is.null(res_sim)){
}
else{
output$responders <- shiny::renderUI({
data <- res_sim$res
responders <- unique(data[[1]]$Cell_id)
shiny::selectInput(inputId = "responders", "Responders", responders)
})
}
if(is.null(res_sim)){
}
else{
output$non_responders <- shiny::renderUI({
data <- res_sim$res
cells <- unique(data[[2]]$Cell_id)
responders <- unique(data[[1]]$Cell_id)
non_responders <- cells %in% responders
non_responders <- unlist(purrr::map2(cells, non_responders, function(x,y) if(y == FALSE){x}))
shiny::selectInput(inputId = "non_responders", "Non Responders", non_responders)
})
}
if(is.null(res_sim)){
}
else{
output$stats_opt <- DT::renderDataTable({
data <- res_sim$res
res2 <- data[[3]][[2]]
res2
})
}
shiny::observeEvent(input$plot_responders, {
data <- res_sim$res
output$plot_cell_sim <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$responders, line = "gam", show_peak = input$show_peak)
p
})
})
shiny::observeEvent(input$plot_non_responders, {
data <- res_sim$res
output$plot_cell_sim <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$non_responders,
line = "gam", show_peak = input$show_peak)
p
})
})
shiny::observeEvent(input$sim_bis, {
print("second stim started")
df <- res_sim$res[[2]]
print("df ok ")
df_sub_bis <- df[df$Cell_id == input$cell_opt]
print("df_sub ok")
res_sim$res_bis <- calipR::downstream_analysis(df_sub_bis, threshold = input$peak_thresh_bis,
borders_range = input$rise_range_bis, lambda = input$lambda_bis,
gam = input$gam_bis, false_pos = input$false_pos_bis, one_cell = TRUE)
})
shiny::observeEvent(input$plot_simulation_bis, {
data <- res_sim$res_bis
output$plot_cell_sim_bis <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$cell_opt, line = "gam", show_peak = input$show_peak_bis)
p
})
})
### Analyze the full dataset
# This block makes the check box "compare groups" reactive
shiny::observe({
group_value <- input$groups
shiny::updateCheckboxInput(shiny::getDefaultReactiveDomain(), "groups", value = group_value)
})
### This block codes alows to launch the analysis when the button analyze dataset is clicked on. It runs the whole analysis, on the whole dataset
res <- shiny::eventReactive(input$ana_full_button, {
df_full <- calipR::get_full_df("db_cq.sqlite", "df_full")
res <- downstream_analysis(df_full, threshold = input$peak_thresh_full,
borders_range = input$rise_full, lambda = input$lambda_full, gam = input$gam_full,
false_pos = input$false_pos_full, compare_groups = input$groups)
# Extracting and saving the data table containing one row for each peak with the informations
#about the peak
res1 <- res[[1]]
print("res1")
print(res1)
calipR::saveData(res1, "db_cq.sqlite", "peak_res")
# Extracting and saving the full data table updated
res2 <- res[[2]]
print("res2")
print(res2)
calipR::saveData(res2, "db_cq.sqlite", "df_final")
res3 <- res[[3]][[2]]
print("res3")
print(res3)
print(str(res3))
res3 <- data.table::setDT(res3)
print(res3)
print(str(res3))
calipR::saveData(res3, "db_cq.sqlite", "stats_desc_final")
print("res3 done")
res
})
output$resp_count <- DT::renderDataTable({
res <- res()
res1 <- res[[3]][[1]]
DT::datatable({res1},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
})
output$resp_group_stim <- DT::renderDataTable({
res <- res()
res2 <- res[[3]][[2]]
DT::datatable({res2},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
})
output$overall_q <- DT::renderDataTable({
res <- res()
if(is.character(res[[3]][[3]][[1]])) {
}
else{
res3 <- res[[3]][[3]][[1]]
DT::datatable({res3},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
}
}
)
output$post_hoc_mcnemar <- DT::renderDataTable({
res <- res()
if(is.character(res[[3]][[3]][[1]])) {
}
else{
res4 <- res[[3]][[3]][[2]]
DT::datatable({res4},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
}
})
### Computing dual proportions (proportion of cells responding to one stimulus that also responds to another stimulus)
output$stim_list_1 <- shiny::renderUI({
res <- get_full_df("db_cq.sqlite", "peak_res")
stim_list <- unique(res$Start_peak_stimulus)
shiny::selectInput(inputId = "stim_list_1", "Stimulus 1", stim_list)
})
output$stim_list_2 <- shiny::renderUI({
res <- get_full_df("db_cq.sqlite", "peak_res")
stim_list <- unique(res$Start_peak_stimulus)
shiny::selectInput(inputId = "stim_list_2", "Stimulus 2", stim_list)
})
t <- shiny::eventReactive(input$dual_button, {
res <- get_full_df("db_cq.sqlite", "peak_res")
t <- dual_prop(res, input$stim_list_1, input$stim_list_2)
})
output$dual_prop <- DT::renderDataTable(
DT::datatable({t()},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
))
### Ajouter des visualisations des pourcentages par groupe, par coverslip etc. :
output$viz <- plotly::renderPlotly({
res <- get_full_df("db_cq.sqlite", "stats_desc_final")
print("res")
print(res)
print(input$x)
print(input$y)
#ggplot2::ggplot(res, ggplot2::aes(x = res[[input$x]], y = res[[input$y]],
# fill = res[[input$x]], shape = res[[input$z]],
#group = interaction(res[[input$x]], res[[input$z]])))+
# ggplot2::geom_boxplot()+
#ggplot2::geom_jitter(position= ggplot2::position_jitterdodge(0.1), size = 5)+
#ggplot2::theme_classic()+
#ggplot2::labs(y = input$y, x = input$x, z = input$z, fill = input$x)
plotly::plot_ly(
type = 'box',
x = res[[input$x]],
y = res[[input$y]],
text = paste("Group: ", res$Group,
"<br>Stimulus:  ", res$Stimulus,
"<br>Responders: ", res$Responses,
"<br>Proportion: ", res$Proportion,
"<br> Total cells: ", res$n_cells),
hoverinfo = 'text',
mode = 'markers',
boxpoints = "all",
jitter = 0.3,
pointpos = 0,
marker = list(size = 9, color = "black"),
color = res[[input$z]],
) %>%
plotly::layout(boxmode ="group", yaxis = list(automargin = TRUE),
xaxis = list(automargin = TRUE), boxgap = -2, boxgroupgap = 0)
})
}
shiny::shinyApp(ui, server)
}
launch_GuiGui()
library(calipR)
library(calipR)
launch_GuiGui
launch_GuiGui()
#' Analyze_Responses
#'
#' @param data
#' @param df_clean
#' @param compare_groups
#'
#' @return
#' @export
#'
#' @examples
Analyze_Responses <- function(data, df_clean, compare_groups = FALSE, one_cell = FALSE){
### Adding a variable "Response" for each stimulus in df_clean
if(compare_groups == FALSE){
d <- unique(df_clean[,c("Cell_id", "stimulus", "coverslip")])
d_list <- split(d,cumsum(1:nrow(d) %in% seq(1:nrow(d))))
d_list <- lapply(d_list, function(x) data.table::setDT(x)[, Response := ifelse(is.na(
data[data$Cell_id == x$Cell_id &
data$Start_peak_stimulus == x$stimulus,]$Cell_id[1]),
FALSE, TRUE) ])
d <- do.call(rbind, d_list)
stim_list <- unique(d$stimulus)
cov_list <- unique(d$coverslip)
n_cells <- length(unique(d$Cell_id))
n_cells_by_cov <- lapply(cov_list, function(x) length(unique(d[d$coverslip == x]$Cell_id)))
n_responders <- length(unique(d[d$Response == TRUE]$Cell_id))
prop_total <- n_responders / n_cells
stats <- data.table::setDT(list("n_cells" = n_cells, "n_responders" = n_responders, "Proportion" = prop_total))
n_responses_by_stim <- unlist(lapply(stim_list, function(x) sum(d$stimulus == x & d$Response == TRUE)))
resp_by_cov_and_stim <- unlist(lapply(cov_list, function(x) lapply(stim_list, function(y) sum(d$coverslip == x & d$stimulus == y & d$Response == TRUE))))
print(cov_list)
print(resp_by_cov_and_stim)
prop_by_stim <- n_responses_by_stim / n_cells
prop_by_stim_responders <- n_responses_by_stim / n_responders
prop_by_stim_cov <- resp_by_cov_and_stim / unlist(rep(n_cells_by_cov, each = length(stim_list)))
print(prop_by_stim_cov)
df_final <- data.frame(Stimulus = stim_list)
df_final$Resp <- n_responses_by_stim
df_final$Proportion_of_responders <- prop_by_stim_responders
df_final$Proportion_of_total_cells <- prop_by_stim
d$Response <- ifelse(d$Response == TRUE, 1,0)
if(one_cell == FALSE){
res <- Compare_props(d)
}
if(one_cell == TRUE){
res = NULL
}
### Peak description by stimulus :
if(length(data$Cell_id) != 0){
data <- data[, peak_duration := End_peak_frame - Start_peak_frame]
}
df_by_cov <- data.frame(Coverslip = rep(cov_list, each = length(stim_list)))
df_by_cov$Stimulus <- rep(stim_list, times = length(cov_list))
df_by_cov$Responses <- resp_by_cov_and_stim
df_by_cov$Proportion <- prop_by_stim_cov
df_by_cov$n_cells <- unlist(rep(n_cells_by_cov, each = length(stim_list)))
df_by_cov <- df_by_cov[df_by_cov$Responses != 0, ]
}
if(compare_groups == TRUE) {
d <- unique(df_clean[,c("Cell_id", "stimulus", "group", "coverslip")])
d_list <- split(d,cumsum(1:nrow(d) %in% seq(1:nrow(d))))
d_list <- lapply(d_list, function(x) data.table::setDT(x)[, Response := ifelse(is.na(
data[data$Cell_id == x$Cell_id &
data$Start_peak_stimulus == x$stimulus &
data$group == x$group,]$Cell_id[1]),
FALSE, TRUE)])
d <- do.call(rbind, d_list)
stim_list <- unique(d$stimulus)
group_list <- unique(d$group)
cov_list <- unique(d$coverslip)
n_cov_by_group <- unlist(lapply(group_list, function(x) length(unique(d[d$group == x]$coverslip))))
n_cells <- length(unique(d$Cell_id))
n_cells_by_group <- lapply(group_list, function(x) as.character(dim(d[d$group == x, .(unique(Cell_id))])[1]))
n_cells_by_cov <- lapply(cov_list, function(x) length(unique(d[d$coverslip == x]$Cell_id)))
n_responders <- length(unique(d[d$Response == TRUE]$Cell_id))
# Réponses par groupe :
n_responses_by_group <- lapply(group_list, function(x) as.character(sum(d$group == x & d$Response == TRUE)))
prop_by_group <- as.character(as.numeric(n_responses_by_group) / as.numeric(unlist(n_cells_by_group)))
stats <- data.table::setDT(list("Group" = group_list, "n_cells" = n_cells_by_group, "n_responders" = n_responses_by_group,
"Proportion" = prop_by_group))
resp_by_group_and_stim <- unlist(lapply(group_list, function(x) lapply(stim_list, function(y) sum(d$group == x & d$stimulus == y & d$Response == TRUE))))
prop_by_group_and_stim_responders <- resp_by_group_and_stim / rep(unlist(as.numeric(n_responses_by_group)), each = length(stim_list))
prop_by_group_and_stim <- resp_by_group_and_stim / rep(unlist(as.numeric(n_cells_by_group)), each = length(stim_list))
resp_by_group_stim_cov <- unlist(lapply(cov_list,function(x) lapply(stim_list, function(y) sum(d$coverslip == x & d$stimulus == y & d$Response == TRUE))))
n_cells_by_cov <- rep(n_cells_by_cov, each = length(stim_list))
prop_by_group_stim_cov <- resp_by_group_stim_cov / unlist(n_cells_by_cov)
group_list <- rep(unlist(purrr::map2(group_list, n_cov_by_group, function(x,y) rep(x, y) )), each = length(stim_list))
df_by_cov <- data.frame(Coverslip = rep(cov_list, each = length(stim_list)))
df_by_cov$Group <- group_list
df_by_cov$Stimulus <- rep(stim_list, times = length(cov_list))
df_by_cov$Responses <- resp_by_group_stim_cov
df_by_cov$Proportion <- prop_by_group_stim_cov
df_by_cov$n_cells <- unlist(n_cells_by_cov)
df_by_cov <- df_by_cov[df_by_cov$Responses != 0, ]
#res <- glmer(Response ~ group * stimulus + (1|Cell_id), family = binomial, data = d)
res <- "NO STATS"
}
print("Analyze Responses OK")
#return(list(data_count, data_count_stim[[2]], between_stim[[1]], between_stim[[2]]))
return(list(stats, df_by_cov, res))
}
library(calipR)
