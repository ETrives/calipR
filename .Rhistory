shiny::textInput("peak_thresh_bis", label = NULL, placeholder = "Enter the peak threshold you want to try (z score)"),
shiny::textInput("rise_range_bis", label = NULL, placeholder = "Enter the range taken to find a peak start (integer between 5 and 60)"),
shiny::textInput("lambda_bis", label = "Lambda", placeholder = "Enter the Lambda parameter for the Deconvolution (integer)"),
shiny::textInput("gam_bis", label = "Gam", placeholder = "Enter the Gam parameter for the Deconvolution (double between 0-1)"),
shiny::actionButton("sim_bis", "Simulate Analysis", align = "center"),
shiny::actionButton("plot_simulation_bis", "Plot Random Cells", align = "center"),
shiny::plotOutput(outputId = "plot_cell_sim_bis"))),
shinydashboard::tabItem("ana_full",
shiny::fluidRow(
shinydashboard::box(title = "Description of Responses", width = 12, solidHeader = TRUE, status = "primary",
shiny::textOutput("resp_count"),
DT::dataTableOutput("resp_group_stim"),
shiny::textOutput("n_peaks"),
DT::dataTableOutput("peaks_by_class"),
DT::dataTableOutput("overall_q"),
DT::dataTableOutput("post_hoc_mcnemar")
)),
shiny::fluidRow(
shinydashboard::box(title = "Dual Proportions", width = 12, solidHeader = TRUE, status = "primary",
shiny::textInput("stim1", label = NULL, placeholder = "Stimulus 1"),
shiny::textInput("stim2", label = NULL, placeholder = "Stimulus 2"),
shiny::actionButton("dual_button", "Compute Dual Proportions", align = "center" ),
shiny::br(),
shiny::br(),
DT::dataTableOutput("dual_prop"),
))
)
)
))
server <- function(input, output){
sqlitePath <- getwd()
folder <- shiny::reactive({
if(is.null(input$folder)) {return()}
else{
folder <- input$folder
folder
}
})
stim_numb <- shiny::reactive({
if(is.null(input$stim_num)) {return()}
else{
stim_numb <- as.numeric(input$stim_num)
stim_numb
}
})
df_final <- shiny::eventReactive(input$launch, {
print("we are inside the reactive function")
print(stim_numb())
df <- CalQuick::prepareData(folder(), stim_numb(), 0.25, compare_groups = TRUE)
CalQuick::saveData(df, "db_cq.sqlite", "df_full")
df
})
output$df_sql <- DT::renderDataTable({
if(is.null(df_final())) {return()}
else{
df <- CalQuick::loading100("db_cq.sqlite", "df_full")
df <- DT::datatable(df)
df
}
})
df_plot <- shiny::eventReactive(input$cell_click, {
df <- CalQuick::get_cell(input$cell, "db_cq.sqlite", "df_full")
df
})
output$plot_cell <- shiny::renderPlot({
p <- CalQuick::cell_plot_shiny(df_plot())
p
})
res_sim <- shiny::reactiveValues(res = NULL)
observeEvent(input$sim, {
print("Simulation started")
df_sub <- CalQuick::get_sub_df("db_cq.sqlite", "df_full", input$n_cells)
res_sim$res <- CalQuick::downstream_analysis(df_sub, threshold = input$peak_thresh,
borders_range = input$rise_range, lambda = input$lambda, gam = input$gam)
data <- res_sim$res
cells <- unique(data[[2]]$Cell_id)
output$cells <- shiny::renderUI({
shiny::selectInput(inputId = "cells_sim", "Cells", cells)
})
})
shiny::observeEvent(input$plot_simulation, {
print("plot trigerred")
data <- res_sim$res
#data_sub <- data[[2]][data[[2]]$Cell_id == input$cells_sim]
output$plot_cell_sim <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$cells_sim, line = "gam", show_peak = TRUE)
p
})
})
shiny::observeEvent(input$sim_bis, {
print("Second simulation started")
df <- res_sim$res[[2]]
df_sub_bis <- df[df$Cell_id == input$cell_opt]
res_sim$res_bis <- CalQuick::downstream_analysis(df_sub_bis, threshold = input$peak_thresh_bis,
borders_range = input$rise_range_bis, lambda = input$lambda_bis, gam = input$gam_bis)
})
shiny::observeEvent(input$plot_simulation_bis, {
print("plot trigerred")
data <- res_sim$res_bis
output$plot_cell_sim_bis <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$cell_opt, line = "gam", show_peak = TRUE)
p
})
})
### Analyze the full dataset
# This block makes the check box "compare groups" reactive
shiny::observe({
group_value <- input$groups
shiny::updateCheckboxInput(shiny::getDefaultReactiveDomain(), "groups", value = group_value)
print(input$groups)
})
### This block codes alows to launch the analysis when the button analyze dataset is clicked on. It runs the whole analysis, on the whole dataset
res <- shiny::eventReactive(input$ana_full_button, {
df_full <- CalQuick::get_full_df("db_cq.sqlite", "df_full")
res <- CalQuick::downstream_analysis(df_full, 4,2,4,input$peak_thresh_full, input$rise_full,2, compare_groups = input$groups)
# Extracting and saving the data table containing one row for each peak with the informations
#about the peak
res1 <- res[[2]]
CalQuick::saveData(res1, "db_cq.sqlite", "peak_res")
# Extracting and saving the full data table updated
res2 <- res[[3]]
CalQuick::saveData(res2, "db_cq.sqlite", "df_final")
res
})
output$resp_count <- shiny::renderText({
res <- res()
res1 <- res[[1]][1][[1]]
res1
})
output$resp_group_stim <- DT::renderDataTable({
res <- res()
res2 <- res[[1]][2][[1]]
res2
})
output$n_peaks <- shiny::renderText({
res <- res()
res3 <- res[[1]][3][[1]]
res3
})
output$peaks_by_class <- DT::renderDataTable({
res <- res()
res4 <- res[[1]][4][[1]]
res4
})
output$overall_q <- DT::renderDataTable({
res <- res()
res4 <- res[[1]][5][[1]]
res4
})
output$post_hoc_mcnemar <- DT::renderDataTable({
res <- res()
res4 <- res[[1]][6][[1]]
res4
})
### Computing dual proportions (proportion of cells responding to one stimulus that also responds to another stimulus)
t <- shiny::eventReactive(input$dual_button, {
res <- get_full_df("db_cq.sqlite", "peak_res")
print(res)
t <- dual_prop(res, input$stim1, input$stim2)
print(t)
})
output$dual_prop <- DT::renderDataTable({
t()
})
}
shiny::shinyApp(ui, server)
}
launch_GuiGui()
library(CalQuick)
library(CalQuick)
launch_GuiGui()
system.file("extdata", package = "CalQuick")
system.file("extdata/VNO", package = "CalQuick")
prepareData(system.file("extdata/VNO", package = "CalQuick"), 5,0.25, compare_groups = TRUE)
test <- prepareData(system.file("extdata/VNO", package = "CalQuick"), 5,0.25, compare_groups = TRUE)
View(test)
system.file("extdata/VNO", package = "CalQuick")
list.files(system.file("extdata/VNO", package = "CalQuick"))
list.files(system.file("extdata/VNO", package = "CalQuick"), pattern = "\\.csv", recursive = T, full.names = T)
my_files <- list.files(system.file("extdata/VNO", package = "CalQuick"), pattern = "\\.csv", recursive = T, full.names = T)
coverslip_id <- lapply(myfiles, function(x) as.integer(stringr::str_replace_all(stringr::str_split(x, "/")[[1]][4], "[.csv.]", "")))
coverslip_id <- lapply(my_files, function(x) as.integer(stringr::str_replace_all(stringr::str_split(x, "/")[[1]][4], "[.csv.]", "")))
coverslip_id
coverslip_id <- lapply(my_files, function(x) stringr::str_split(x, "/")[[1]][4], "[.csv.]", "")
coverslip_id <- lapply(my_files, function(x) stringr::str_split(x, "/")[[1]][4])
coverslip_id
coverslip_id <- lapply(my_files, function(x) stringr::str_split(x, "/")[[1]])
coverslip_id
coverslip_id <- lapply(my_files, function(x) stringr::str_split(x, "/"))
coverslip_id
coverslip_id <- lapply(my_files, function(x) stringr::str_split(x, "/")[[1]])
coverslip_id
coverslip_id <- lapply(my_files, function(x) stringr::str_split(x, "/")[[1]][12])
coverslip_id
#' @examples
prepareData <- function(folder_name, stim_number, frame_rate,  duration_in_seconds = 30, compare_groups = FALSE,
example_data = FALSE
) {
# Get the file names and store the content in a list of df :
myFiles <- list.files(folder_name, pattern = "\\.csv", recursive = T, full.names = T)
# Removing the meta_data file :
myFiles <- myFiles[!stringr::str_detect(myFiles,pattern="meta")]
meta <- list.files(folder_name, pattern = "meta", recursive = T, full.names = T)
df_list <- vector(mode = "list", length = length(myFiles))
# Reading all the files
df_list <- lapply(myFiles, function(x) data.table::fread(x, skip = 1, header = FALSE))
df_list <- lapply(df_list, function(x) x[,2:length(x)])
df_list <- lapply(df_list, function(x) setnames(x, paste0(rep("Mean", length(x)), seq(1: length(x)))))
# Code pour récupérer uniquement le numéro du coverslip et lui ajouter une lettre :
if(example_data == TRUE){
coverslip_id <- lapply(myFiles, function(x) as.integer(stringr::str_replace_all(stringr::str_split(x, "/")[[1]][12], "[.csv.]", "")))
}
if(example_data == FALSE){
coverslip_id <- lapply(myFiles, function(x) as.integer(stringr::str_replace_all(stringr::str_split(x, "/")[[1]][4], "[.csv.]", "")))
}
letter_list <- LETTERS[seq(from = 1, to = length(myFiles))]
coverslip_id <- purrr::map2(letter_list, coverslip_id, function(x,y) paste(x,y,sep =""))
# Fetching the stimuli informations :
meta_df <- data.table::fread(meta)
stimuli <- meta_df$stimuli
stimuli <- split(stimuli, ceiling(seq_along(stimuli)/stim_number))
stimuli <- lapply(stimuli, function(x) purrr::map2(seq_along(1:stim_number), x, function(y, z) paste(y,z, sep=".")))
# now the time informations :
each <- meta_df$timing
each <- split(each, ceiling(seq_along(each)/stim_number))
# Get the pattern to find in the colnames for the cell_srt function :
pattern <- substr(colnames(df_list[[1]])[2], 1,4)
### Code pour récupérer uniquement le groupe auquel appartient un coverslip
group_list <- lapply(myFiles, function(x) stringr::str_split(x, "/")[[1]][2])
if(compare_groups == TRUE) {
for(i in 1:length(df_list)){
# voir pour executer tidy_df sur chaque élément de df_list via un pmap ? :
df_list[[i]] <- tidy_df(df_list[[i]],stimuli[[i]], each[[i]], pattern,
duration_in_seconds, frame_rate, coverslip_id = coverslip_id[[i]], id = i,
multiple = TRUE, compare_groups = TRUE, group_list[[i]])
}
}
if(compare_groups == FALSE) {
for(i in 1:length(df_list)){
df_list[[i]] <- tidy_df(df_list[[i]],stimuli[[i]], each[[i]], pattern, duration_in_seconds, frame_rate, coverslip_id = i, id = i, multiple = TRUE, compare_groups = FALSE, group_list[[i]])
}
}
df <- do.call(rbind, df_list)
#write.csv(df, "df_manip_maxime.csv")
return(df)
}
test <- prepareData(system.file("extdata/VNO", package = "CalQuick"), 5,0.25, compare_groups = TRUE, example_data = TRUE)
test
coverslip_id <- lapply(my_files, function(x) stringr::str_split(x, "/")[[1]])
coverslip_id
lapply(my_files, function(x) stringr::str_split(x, "/")[[1]])
lapply(my_files, function(x) stringr::str_split(x, "/")[[1]])
length(lapply(my_files, function(x) stringr::str_split(x, "/")[[1]]))
lapply(lapply(my_files, function(x) stringr::str_split(x, "/")[[1]]), function(x) length(x))
stringr::str_split(my_files[[1]], "/")[[1]]
#' @examples
prepareData <- function(folder_name, stim_number, frame_rate,  duration_in_seconds = 30, compare_groups = FALSE,
example_data = FALSE
) {
# Get the file names and store the content in a list of df :
myFiles <- list.files(folder_name, pattern = "\\.csv", recursive = T, full.names = T)
# Removing the meta_data file :
myFiles <- myFiles[!stringr::str_detect(myFiles,pattern="meta")]
meta <- list.files(folder_name, pattern = "meta", recursive = T, full.names = T)
df_list <- vector(mode = "list", length = length(myFiles))
# Reading all the files
df_list <- lapply(myFiles, function(x) data.table::fread(x, skip = 1, header = FALSE))
df_list <- lapply(df_list, function(x) x[,2:length(x)])
df_list <- lapply(df_list, function(x) setnames(x, paste0(rep("Mean", length(x)), seq(1: length(x)))))
# Code pour récupérer uniquement le numéro du coverslip et lui ajouter une lettre :
if(example_data == TRUE){
index <-length(stringr::str_split(myFiles[[1]], "/")[[1]])
coverslip_id <- lapply(myFiles, function(x) as.integer(stringr::str_replace_all(stringr::str_split(x, "/")[[1]][index], "[.csv.]", "")))
}
if(example_data == FALSE){
coverslip_id <- lapply(myFiles, function(x) as.integer(stringr::str_replace_all(stringr::str_split(x, "/")[[1]][4], "[.csv.]", "")))
}
letter_list <- LETTERS[seq(from = 1, to = length(myFiles))]
coverslip_id <- purrr::map2(letter_list, coverslip_id, function(x,y) paste(x,y,sep =""))
# Fetching the stimuli informations :
meta_df <- data.table::fread(meta)
stimuli <- meta_df$stimuli
stimuli <- split(stimuli, ceiling(seq_along(stimuli)/stim_number))
stimuli <- lapply(stimuli, function(x) purrr::map2(seq_along(1:stim_number), x, function(y, z) paste(y,z, sep=".")))
# now the time informations :
each <- meta_df$timing
each <- split(each, ceiling(seq_along(each)/stim_number))
# Get the pattern to find in the colnames for the cell_srt function :
pattern <- substr(colnames(df_list[[1]])[2], 1,4)
### Code pour récupérer uniquement le groupe auquel appartient un coverslip
if(example_data == TRUE){
group_list <- lapply(myFiles, function(x) stringr::str_split(x, "/")[[1]][12])
}
if(example_data == FALSE){
group_list <- lapply(myFiles, function(x) stringr::str_split(x, "/")[[1]][2])
}
if(compare_groups == TRUE) {
for(i in 1:length(df_list)){
# voir pour executer tidy_df sur chaque élément de df_list via un pmap ? :
df_list[[i]] <- tidy_df(df_list[[i]],stimuli[[i]], each[[i]], pattern,
duration_in_seconds, frame_rate, coverslip_id = coverslip_id[[i]], id = i,
multiple = TRUE, compare_groups = TRUE, group_list[[i]])
}
}
if(compare_groups == FALSE) {
for(i in 1:length(df_list)){
df_list[[i]] <- tidy_df(df_list[[i]],stimuli[[i]], each[[i]], pattern, duration_in_seconds, frame_rate, coverslip_id = i, id = i, multiple = TRUE, compare_groups = FALSE, group_list[[i]])
}
}
df <- do.call(rbind, df_list)
#write.csv(df, "df_manip_maxime.csv")
return(df)
}
test <- prepareData(system.file("extdata/VNO", package = "CalQuick"), 5,0.25, compare_groups = TRUE, example_data = TRUE)
tes
test
test <- prepareData("VNO", 5,0.25, compare_groups = TRUE)
test <- prepareData("/extdata/VNO", 5,0.25, compare_groups = TRUE)
test <- prepareData("extdata/VNO", 5,0.25, compare_groups = TRUE)
test <- prepareData("inst/extdata/VNO", 5,0.25, compare_groups = TRUE)
test
#' @examples
prepareData <- function(folder_name, stim_number, frame_rate,  duration_in_seconds = 30, compare_groups = FALSE,
example_data = FALSE
) {
# Get the file names and store the content in a list of df :
myFiles <- list.files(folder_name, pattern = "\\.csv", recursive = T, full.names = T)
# Removing the meta_data file :
myFiles <- myFiles[!stringr::str_detect(myFiles,pattern="meta")]
meta <- list.files(folder_name, pattern = "meta", recursive = T, full.names = T)
df_list <- vector(mode = "list", length = length(myFiles))
# Reading all the files
df_list <- lapply(myFiles, function(x) data.table::fread(x, skip = 1, header = FALSE))
df_list <- lapply(df_list, function(x) x[,2:length(x)])
df_list <- lapply(df_list, function(x) setnames(x, paste0(rep("Mean", length(x)), seq(1: length(x)))))
# Code pour récupérer uniquement le numéro du coverslip et lui ajouter une lettre :
index <-length(stringr::str_split(myFiles[[1]], "/")[[1]])
coverslip_id <- lapply(myFiles, function(x) as.integer(stringr::str_replace_all(stringr::str_split(x, "/")[[1]][index], "[.csv.]", "")))
letter_list <- LETTERS[seq(from = 1, to = length(myFiles))]
coverslip_id <- purrr::map2(letter_list, coverslip_id, function(x,y) paste(x,y,sep =""))
# Fetching the stimuli informations :
meta_df <- data.table::fread(meta)
stimuli <- meta_df$stimuli
stimuli <- split(stimuli, ceiling(seq_along(stimuli)/stim_number))
stimuli <- lapply(stimuli, function(x) purrr::map2(seq_along(1:stim_number), x, function(y, z) paste(y,z, sep=".")))
# now the time informations :
each <- meta_df$timing
each <- split(each, ceiling(seq_along(each)/stim_number))
# Get the pattern to find in the colnames for the cell_srt function :
pattern <- substr(colnames(df_list[[1]])[2], 1,4)
### Code pour récupérer uniquement le groupe auquel appartient un coverslip
if(example_data == TRUE){
group_list <- lapply(myFiles, function(x) stringr::str_split(x, "/")[[1]][12])
}
if(example_data == FALSE){
group_list <- lapply(myFiles, function(x) stringr::str_split(x, "/")[[1]][2])
}
if(compare_groups == TRUE) {
for(i in 1:length(df_list)){
# voir pour executer tidy_df sur chaque élément de df_list via un pmap ? :
df_list[[i]] <- tidy_df(df_list[[i]],stimuli[[i]], each[[i]], pattern,
duration_in_seconds, frame_rate, coverslip_id = coverslip_id[[i]], id = i,
multiple = TRUE, compare_groups = TRUE, group_list[[i]])
}
}
if(compare_groups == FALSE) {
for(i in 1:length(df_list)){
df_list[[i]] <- tidy_df(df_list[[i]],stimuli[[i]], each[[i]], pattern, duration_in_seconds, frame_rate, coverslip_id = i, id = i, multiple = TRUE, compare_groups = FALSE, group_list[[i]])
}
}
df <- do.call(rbind, df_list)
#write.csv(df, "df_manip_maxime.csv")
return(df)
}
test <- prepareData("inst/extdata/VNO", 5,0.25, compare_groups = TRUE)
test
stringr::str_split(my_files[[1]], "/")[[1]]
#' @examples
prepareData <- function(folder_name, stim_number, frame_rate,  duration_in_seconds = 30, compare_groups = FALSE
) {
# Get the file names and store the content in a list of df :
myFiles <- list.files(folder_name, pattern = "\\.csv", recursive = T, full.names = T)
# Removing the meta_data file :
myFiles <- myFiles[!stringr::str_detect(myFiles,pattern="meta")]
meta <- list.files(folder_name, pattern = "meta", recursive = T, full.names = T)
df_list <- vector(mode = "list", length = length(myFiles))
# Reading all the files
df_list <- lapply(myFiles, function(x) data.table::fread(x, skip = 1, header = FALSE))
df_list <- lapply(df_list, function(x) x[,2:length(x)])
df_list <- lapply(df_list, function(x) setnames(x, paste0(rep("Mean", length(x)), seq(1: length(x)))))
# Code pour récupérer uniquement le numéro du coverslip et lui ajouter une lettre :
index_cov <-length(stringr::str_split(myFiles[[1]], "/")[[1]])
coverslip_id <- lapply(myFiles, function(x) as.integer(stringr::str_replace_all(stringr::str_split(x, "/")[[1]][index_cov], "[.csv.]", "")))
letter_list <- LETTERS[seq(from = 1, to = length(myFiles))]
coverslip_id <- purrr::map2(letter_list, coverslip_id, function(x,y) paste(x,y,sep =""))
# Fetching the stimuli informations :
meta_df <- data.table::fread(meta)
stimuli <- meta_df$stimuli
stimuli <- split(stimuli, ceiling(seq_along(stimuli)/stim_number))
stimuli <- lapply(stimuli, function(x) purrr::map2(seq_along(1:stim_number), x, function(y, z) paste(y,z, sep=".")))
# now the time informations :
each <- meta_df$timing
each <- split(each, ceiling(seq_along(each)/stim_number))
# Get the pattern to find in the colnames for the cell_srt function :
pattern <- substr(colnames(df_list[[1]])[2], 1,4)
### Code pour récupérer uniquement le groupe auquel appartient un coverslip
index_gr <-length(stringr::str_split(myFiles[[1]], "/")[[1]])-2
group_list <- lapply(myFiles, function(x) stringr::str_split(x, "/")[[1]][index_gr])
if(compare_groups == TRUE) {
for(i in 1:length(df_list)){
# voir pour executer tidy_df sur chaque élément de df_list via un pmap ? :
df_list[[i]] <- tidy_df(df_list[[i]],stimuli[[i]], each[[i]], pattern,
duration_in_seconds, frame_rate, coverslip_id = coverslip_id[[i]], id = i,
multiple = TRUE, compare_groups = TRUE, group_list[[i]])
}
}
if(compare_groups == FALSE) {
for(i in 1:length(df_list)){
df_list[[i]] <- tidy_df(df_list[[i]],stimuli[[i]], each[[i]], pattern, duration_in_seconds, frame_rate, coverslip_id = i, id = i, multiple = TRUE, compare_groups = FALSE, group_list[[i]])
}
}
df <- do.call(rbind, df_list)
#write.csv(df, "df_manip_maxime.csv")
return(df)
}
test <- prepareData("inst/extdata/VNO", 5,0.25, compare_groups = TRUE)
test
example_data_1 <- function() {
data <- prepareData(system.file("extdata/VNO", package = "CalQuick"), 5,0.25, compare_groups = TRUE)
return(data)
}
example_data_1()
example_data_2 <- function() {
data <- prepareData(system.file("extdata/test_1", package = "CalQuick"), 2,1, compare_groups = FALSE)
return(data)
}
example_data_2()
example_data_2 <- function() {
data <- prepareData(system.file("extdata/test1", package = "CalQuick"), 2,1, compare_groups = FALSE)
return(data)
}
example_data_2()
library(CalQuick)
library(CalQuick)
example_data_1()
launch_GuiGui()
system.files("model/model.rds", package = "CalQuick")
system.file("model/model.rds", package = "CalQuick")
readRDS(system.file("model/model.rds", package = "CalQuick"))
#' keep_best_peaks
#'
#' @param data the whole output from find_peaks function
#' @param range
#'
#' @return the same objects with an added column named True_Peaks which is TRUE if the peak is kept, FALSE if not
#' @export
#'
#' @examples
keep_best_peaks <- function(data){
#data[[1]] <- data.table::setDT(data[[1]])[, True_peak := Max_peak_smooth_z == max(Max_peak_smooth_z), by = list(Cell_id, Max_peak_stimulus)]
#data[[2]] <- data.table::setDT(data[[2]])[, True_peak := smooth_z == max(smooth_z), by = list(Cell_id, stimulus)]
#peaks_data  <- data[[1]][data[[1]]$True_peak == TRUE,]
#peaks_list <- split(peaks_data,cumsum(1:nrow(peaks_data) %in% seq(1:nrow(peaks_data))))
peaks_list <- split(data[[1]],cumsum(1:nrow(data[[1]]) %in% seq(1:nrow(data[[1]]))))
peaks_list <- lapply(peaks_list, function(x) x[, infValue :=  inferiorValues(x, data[[2]])])
peaks_list <- lapply(peaks_list, function(x) x[, bimod_peak :=  bimodal_cell(x, data[[2]])])
data_peaks <- do.call(rbind, peaks_list)
model <- readRDS(system.file("model/model.rds", package = "CalQuick"))
#readRDS("model.rds")
data_peaks[, Prediction := predict(model, data_peaks, type="response")]
data_final <- data_peaks[data_peaks$Prediction > 0.5,]
return(list(data_final, data[[2]],data_peaks))
}
test_1Hz_bis <- example_data_2()
test_clean_1Hz <- clean_data(test_1Hz_bis, 0.1, 2, mean_width = 20, DPA_width = 10, mean_width_diff = 10)
test_back_1Hz <- backEstimate(test_clean_1Hz, method = "gam")
test_norm_1Hz <- norm_df(test_back_1Hz, var = "gam", width = 10)
test_deconvolve <- deconvolve(test_norm_1Hz, lambda = 100, gam = 0.97, constraint =T, threshold = 2, var = "gam_detrended")
#' @param constraint
#' @param estimate_calcium
#' @param var
#' @param ESP
#' @param threshold
#'
#' @return
#' @export
#'
#' @examples
deconvolve <- function(norm_data, gam = 0.95, lambda = 1, constraint = T, estimate_calcium = T, var = "smooth_delta", ESP = 0.0001,
threshold = 3) {
cells <- unique(norm_data$Cell_id)
cell_split <- split(norm_data, norm_data$Cell_id)
cell_split <- lapply(cell_split, function(x) add_peak_info(x, gam = gam, lambda = lambda,constraint, estimate_calcium, var, ESP))
peaks_data <- lapply(cell_split, function(x) if(length(x$peak_frames)[[1]] != 0) {x[x$time_frame %in% x$peak_frames[[1]]]} )
peaks_data <- lapply(peaks_data, function(x) if(dim(x)[[1]] != 0) {x[, frame_window := x$time_frame +20]} )
data <- do.call(rbind, cell_split)
peaks_data <- do.call(rbind, peaks_data)
peaks_data <- split(peaks_data,cumsum(1:nrow(peaks_data) %in% seq(1:nrow(peaks_data))))
peaks_data <- lapply(peaks_data, function(x) data[data$smooth_z == max(data[data$Cell_id == x$Cell_id & data$time_frame %between% list(x$time_frame, x$frame_window)]$smooth_z)[[1]]])
peaks_data <- lapply(peaks_data, function(x) if(x$smooth_z[[1]] >= threshold) {x} )
peaks_data <- do.call(rbind, peaks_data)
peaks_data <- dplyr::rename(peaks_data,  "Max_peak_stimulus" = "stimulus", "Max_peak_frame" = "time_frame", "Max_peak_stimulation" = "Stimulation",
"Max_peak_smooth_z" = "smooth_z", "Max_peak_first_derivative" = "first_derivative" )
return(list(peaks_data, data))
}
test_deconvolve <- deconvolve(test_norm_1Hz, lambda = 100, gam = 0.97, constraint =T, threshold = 2, var = "gam_detrended")
test_best_1Hz <- keep_best_peaks(test_deconvolve)
test_borders_1Hz <- find_borders(test_best_1Hz, 50)
#test_classify_1Hz <- classify_peaks(test_borders_1Hz, time_thresh = 1, frame_rate = 0.25)
test_resp_1 <- Analyze_Responses(test_borders_1Hz[[1]], test_clean_1Hz, compare_groups = FALSE)
test_resp_1
library(CalQuick)
