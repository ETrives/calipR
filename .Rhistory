}
})
output$non_resp_viz <- shiny::renderUI({
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'df_final'"))[1] == 0) {
}
else{
cells <- unique(result$full[["Cell_id"]])
responders <- unique(result$peaks[["Cell_id"]])
non_responders <- cells %in% responders
non_responders <- unlist(purrr::map2(cells, non_responders, function(x,y) if(y == FALSE){x}))
shiny::selectInput(inputId = "non_resp_viz", "Non Responders", non_responders)
}
})
shiny::observeEvent(input$plot_button,{
output$plot_resp_viz <- renderPlot({
cnames <- colnames(result$full)
back_estim_opt <- c("gam_fit", "background")
cnames_check <- back_estim_opt %in% cnames
back_var <- back_estim_opt[[which(cnames_check == TRUE)]]
# OpÃ©rer un tri sur les cellules regarder comment j'ai fais pour responders
p <- cell_plot(result$full, result$peaks, var = "Mean_Grey", cell = input$resp_viz, line = back_var, show_peak = input$show_peaks_box)
p
})
})
shiny::observeEvent(input$plot_button_bis,{
output$plot_resp_viz <- renderPlot({
cnames <- colnames(result$full)
back_estim_opt <- c("gam_fit", "background")
cnames_check <- back_estim_opt %in% cnames
back_var <- back_estim_opt[[which(cnames_check == TRUE)]]
p <- cell_plot(result$full, result$peaks, var = "Mean_Grey", cell = input$non_resp_viz, line = back_var, show_peak = input$show_peaks_box)
p
})
})
output$clustering_var <- shiny::renderUI({
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'df_final'"))[1] == 0) {
}
else{
list_var <- names(result$full)
shiny::selectInput(inputId = "clustvar", "Variable used for clustering", list_var)
}
})
shiny::observeEvent(input$set_seed, {
if(input$set_seed){
output$seed_field <- shiny::renderUI({
shiny::textInput("seed", "Enter Seed Value")
})
}
else{
output$seed_field <- NULL
}
})
shiny::observeEvent(input$clustplot_button, {
responding_cells <- unique(result$peaks[["Cell_id"]])
dt <- result$full[Cell_id %in% responding_cells]
final <- prepareClustData(dt, input$clustvar, norm = input$normclust)
if(input$set_seed){
set.seed(as.integer(input$seed))
}
clust_res <- dtwclust::tsclust(final, type = "partitional", k = as.integer(input$nclust), distance = input$dist_type,
centroid = "dba")
output$clustplot <- shiny::renderPlot({
p <- plot(clust_res, type="sc")
p
})
})
}
shiny::shinyApp(ui, server)
}
guigui()
#' least one condition then post hoc pairwise comparisons are calculated with a mcnemar test.
#'
#' @param data
#' @param df_clean
#' @param compare_groups
#'
#' @return
#' @export
#'
#' @examples
Analyze_Responses <- function(data, df_clean, compare_groups = FALSE, one_cell = FALSE, marker = FALSE, var_list = NULL, simulation = FALSE){
data <- setDT(data)
df_clean <- setDT(df_clean)
#data$spike_stimulus <- str_replace_all(data$spike_stimulus, "[123456789.]", "")
#df_clean$stimulus <- str_replace_all(df_clean$stimulus, "[123456789.]", "")
data$spike_stimulus
'isnotna' <- Negate('is.na')
df_clean <- df_clean[ isnotna(stimulus)]
data <- data[ isnotna(spike_stimulus)]
### Adding a variable "Response" for each stimulus in df_clean
'%notin%' <- Negate('%in%')
if(simulation == TRUE){
d <- unique(df_clean[,c("Cell_id", "stimulus")])
}
else if(simulation == FALSE){
if(is.null(var_list) & compare_groups == FALSE) {
d <- unique(df_clean[,c("Cell_id", "stimulus")])
}
else if(is.null(var_list) & compare_groups == TRUE){
d <- unique(df_clean[,c("Cell_id", "stimulus", "group")])
}
else{
d <- unique(df_clean[,c(c("Cell_id","stimulus"), ..var_list)])
}
}
d <- data.table::setDT(d)
data <- data.table::setDT(data)
setkey(d, Cell_id, stimulus)
setkey(data, Cell_id, spike_stimulus)
response_indices <- unique(d[data, which = TRUE])
d$Response <- FALSE
d$Response[response_indices] <- TRUE
stim_list <- unique(d$stimulus)
n_cells_tot <- length(unique(d$Cell_id))
if("coverslip" %in% var_list){
n_cells_cov <- d[, .(n_cells = length(unique(Cell_id))), by = coverslip]
}
if("group" %in% var_list){
n_cells_grp <- d[, .(n_cells = length(unique(Cell_id))), by = group]
}
if("marker_positive" %in% var_list){
marker_list <- unique(d$marker_positive)
}
n_cells_cond <- d[, .(n_cells = length(unique(Cell_id))), by = var_list]
if(simulation == TRUE) {
data <- d[, .(Responders = sum(Response)), by = stimulus]
data <- data[, c("Prop", "n_cells_tot") := list(Responders/ n_cells_tot, n_cells_tot)]
}
else{
if(is.null(var_list)){
d <- unique(d[,c("Cell_id", "Response", "stimulus")])
data <- d[, .(Responders = sum(Response)), by = stimulus]
}
else{
d <- unique(d[,c(c("Cell_id", "Response"), ..var_list)])
data <- d[, .(Responders = sum(Response)), by = var_list]
}
if("coverslip" %notin% var_list & "group" %notin% var_list & "marker_positive" %notin% var_list ){
data <- data[, c("Prop", "n_cells_tot") := list(Responders/ n_cells_tot, n_cells_tot)]
}
if("coverslip" %notin% var_list & "stimulus" %notin% var_list & "group" %in% var_list & "marker_positive" %notin% var_list){
data <- data[, c("Prop", "n_cells_grp") := list(Responders/ n_cells_grp$n_cells, n_cells_grp$n_cells)]
}
if("coverslip" %notin% var_list & "stimulus" %in% var_list & "group" %in% var_list & "marker_positive" %notin% var_list){
n_cells_grp <- rep(n_cells_grp$n_cells, each = length(stim_list))
data <- data[, c("Prop", "n_cells_grp") := list(Responders/ n_cells_grp, n_cells_grp)]
}
if("coverslip" %notin% var_list & "stimulus" %notin% var_list & "group" %notin% var_list & "marker_positive" %in% var_list){
n_cells_tot <- rep(n_cells_tot, each = length(marker_list))
data <- data[, c("n_cells_tot", "Prop_tot", "n_cells_marker", "Prop_marker_resp", "Prop_marker")
:= list(n_cells_tot, Responders/ n_cells_tot, n_cells_cond$n_cells,
Responders/ n_cells_cond$n_cells, n_cells_cond$n_cells/n_cells_tot )]
}
if("coverslip" %notin% var_list & "group" %notin% var_list & "stimulus" %in% var_list & "marker_positive" %in% var_list){
n_cells_tot <- rep(n_cells_tot, each = length(marker_list)*length(stim_list))
data <- data[, c("n_cells_tot", "Prop_tot", "n_cells_marker", "Prop_marker_resp", "Prop_marker")
:= list(n_cells_tot, Responders/ n_cells_tot, n_cells_cond$n_cells,
Responders/ n_cells_cond$n_cells, n_cells_cond$n_cells/n_cells_tot )]
}
if("coverslip" %notin% var_list & "group" %in% var_list & "stimulus" %in% var_list & "marker_positive" %in% var_list){
data$marker_positive <- factor(data$marker_positive, levels = marker_list, ordered = TRUE)
data <- data[order(marker_positive)]
n_cells_cond <- n_cells_cond[order(marker_positive)]
group_list <- unique(d$group)
n_cells_grp <- rep(rep(n_cells_grp$n_cells, each = length(stim_list)), times = length(marker_list))
data <- data[, c("n_cells_grp", "Prop_tot", "n_cells_marker", "Prop_marker_resp", "Prop_marker")
:= list(n_cells_grp, Responders/ n_cells_grp, n_cells_cond$n_cells,
Responders/ n_cells_cond$n_cells, n_cells_cond$n_cells/n_cells_grp )]
}
if("coverslip" %notin% var_list & "group" %in% var_list & "stimulus" %notin% var_list & "marker_positive" %in% var_list){
data <- data[order(marker_positive)]
n_cells_cond <- n_cells_cond[order(marker_positive)]
group_list <- unique(d$group)
n_cells_tot <- rep(n_cells_tot, each = length(marker_list)*length(group_list))
n_cells_grp <- rep(n_cells_grp$n_cells, times = length(marker_list))
data <- data[, c("n_cells_grp", "Prop_tot", "n_cells_marker", "Prop_marker_resp", "Prop_marker")
:= list(n_cells_grp, Responders/ n_cells_grp, n_cells_cond$n_cells,
Responders/ n_cells_cond$n_cells, n_cells_cond$n_cells/n_cells_grp )]
}
if("coverslip" %in% var_list & "stimulus" %notin% var_list & "group" %notin% var_list & "marker_positive" %notin% var_list){
data <- data[, c("Prop", "n_cells_cov") := list(data$Responders/ n_cells_cov$n_cells, n_cells_cov$n_cells)]
}
if("coverslip" %in% var_list & "stimulus" %in% var_list & "marker_positive" %notin% var_list & "group" %notin% var_list){
n_cells_cov <- rep(n_cells_cov$n_cells, each = length(stim_list))
data <- data[, c("Prop", "n_cells_cov") := list(Responders/ n_cells_cov, n_cells_cov)]
}
if("coverslip" %in% var_list & "stimulus" %in% var_list & "marker_positive" %in% var_list & "group" %notin% var_list){
data <- data[order(marker_positive)]
n_cells_cond <- n_cells_cond[order(marker_positive)]
n_cells_cov <- rep(rep(n_cells_cov$n_cells, each = length(stim_list)), times = length(marker_list))
data <- data[, c("Prop_cov_marker", "n_cells_cov_marker", "Prop_cov", "n_cells_cov", "Prop_pos_cells_cov") := list(Responders/ n_cells_cond$n_cells, n_cells_cond$n_cells, Responders/ n_cells_cov, n_cells_cov, n_cells_cond$n_cells/n_cells_cov)]
}
if("coverslip" %in% var_list & "stimulus" %notin% var_list & "marker_positive" %in% var_list & "group" %notin% var_list){
n_cells_cond <- d[, .(n_cells = length(unique(Cell_id))), by = list(coverslip, marker_positive)]
data <- data[order(marker_positive)]
n_cells_cov <- rep(n_cells_cov$n_cells, times = length(marker_list))
data <- data[, c("Prop_cov_marker", "n_cells_cov_marker", "Prop_cov", "n_cells_cov", "Prop_pos_cells_cov") := list(Responders/ n_cells_cond$n_cells, n_cells_cond$n_cells, Responders/ n_cells_cov , n_cells_cov, n_cells_cond/n_cells_cov)]
}
if("coverslip" %in% var_list & "stimulus" %notin% var_list & "marker_positive" %in% var_list & "group" %in% var_list){
data <- data[order(marker_positive)]
n_cells_cond <- n_cells_cond[order(marker_positive)]
n_cells_cov <- rep(n_cells_cov$n_cells, times = length(marker_list))
data <- data[, c("Prop", "n_cells_cov_marker", "Prop_cov", "n_cell_cov") := list(Responders/ n_cells_cond$n_cells, n_cells_cond$n_cells, Responders/n_cells_cov, n_cells_cov)]
n_cells_cond <- n_cells_cond[order(group, coverslip)]
n_cov_group <-  d[, .(n_cov = length(unique(coverslip))), by = group]
data <- data[order(coverslip)]
n_cells_grp <- unlist(lapply(seq(length(n_cov_group$n_cov)), function(x) rep(n_cells_grp$n_cells[[x]], each = n_cov_group$n_cov[[x]]*length(marker_list))))
data <- data[, c("n_cells_grp", "Prop_marker_resp_grp", "Prop_marker_cov_grp", "Prop_marker_cov") := list(n_cells_grp, Responders / n_cells_grp, n_cells_cond$n_cells/n_cells_grp, n_cells_cond$n_cells/n_cell_cov )]
}
if("coverslip" %in% var_list & "stimulus" %in% var_list & "marker_positive" %in% var_list & "group" %in% var_list){
data <- data[order(marker_positive)]
n_cells_cond <- n_cells_cond[order(marker_positive)]
n_cells_cov <- rep(rep(n_cells_cov$n_cells, each = length(stim_list), times = length(marker_list)))
data <- data[, c("Prop", "n_cells_cov_marker", "Prop_cov", "n_cell_cov") := list(Responders/ n_cells_cond$n_cells, n_cells_cond$n_cells, Responders/n_cells_cov, n_cells_cov)]
n_cells_cond <- n_cells_cond[order(group, coverslip)]
n_cov_group <-  d[, .(n_cov = length(unique(coverslip))), by = group]
data <- data[order(coverslip)]
n_cells_grp <- rep(unlist(lapply(seq(length(n_cov_group$n_cov)), function(x) rep(n_cells_grp$n_cells[[x]], each = n_cov_group$n_cov[[x]]*length(marker_list)))), each = length(stim_list))
data <- data[, c("n_cells_grp", "Prop_marker_resp_grp", "Prop_marker_cov_grp", "Prop_marker_cov") := list(n_cells_grp, Responders / n_cells_grp, n_cells_cond$n_cells/n_cells_grp, n_cells_cond$n_cells/n_cell_cov )]
}
if("coverslip" %in% var_list & "stimulus" %in% var_list & "marker_positive" %notin% var_list & "group" %in% var_list){
n_cells_cond <- n_cells_cond[order(group)]
n_cells_cov <- rep(n_cells_cov$n_cells, each = length(stim_list))
data <- data[, c("Prop", "n_cells_cov_marker", "Prop_cov", "n_cell_cov") := list(Responders/ n_cells_cond$n_cells, n_cells_cond$n_cells, Responders/n_cells_cov, n_cells_cov)]
n_cells_cond <- n_cells_cond[order(group, coverslip)]
n_cov_group <-  d[, .(n_cov = length(unique(coverslip))), by = group]
data <- data[order(coverslip)]
n_cells_grp <- rep(unlist(lapply(seq(length(n_cov_group$n_cov)), function(x) rep(n_cells_grp$n_cells[[x]], each = n_cov_group$n_cov[[x]]))), each = length(stim_list))
data <- data[, c("n_cells_grp", "Prop_resp_grp", "Prop_cov_grp", "Prop_cov") := list(n_cells_grp, Responders / n_cells_grp, n_cells_cond$n_cells/n_cells_grp, n_cells_cond$n_cells/n_cell_cov )]
}
}
if(one_cell == FALSE & compare_groups == FALSE) {
res <- Compare_props(d)
}
if(one_cell == TRUE){
res = NULL
}
if(one_cell == FALSE & compare_groups == TRUE){
res <- "NO STATS"
}
print("Analyze Responses OK")
return(list(data, res))
}
guigui()
#' Response_by_stim_and_groups
#'
#' @param data the first output from find_rise() (a data frame with one line summarizing the informations of one response)
#' @param df_clean the output from clean_data() (the full but cleaned data frame)
#'
#' @return
#' @export
#'
#' @examples
Response_by_stim_and_groups <- function(data, df_clean){
#data$Start_peak_stimulus <- str_replace_all(data$Start_peak_stimulus, "[12345.]", "")
#df_clean$stimulus <- str_replace_all(df_clean$stimulus, "[12345.]", "")
# choper les cellules qui ont plsieurs pics par stimulus :
tab1 <- data.frame(table(data$Cell_id, data$True_peak, data$Start_peak_stimulus))
cell_list <- filter(tab1, Freq > 1)$Var1
# rÃ©cupÃ©rer les indices d'oÃ¹ sont ces doublons
ind <- which(data$Cell_id %in% cell_list)
# AprÃ¨s avoir regardÃ© ces cellules, elles ont un profil parfois atypique
# on peut dÃ©cider de les enlever totalement :
'%notin%' <- Negate('%in%')
data <- data[data$Cell_id %notin% cell_list,]
# A partir de lÃ , il suffit de prendre les stats faites sur les pics, par groupe et par stimulus et
# Ã§a correspond au nombre de cellules qui rÃ©pondent par stimulus et par groupe et par coverslip
# pour le rentrer en covariÃ©
# rÃ©cupÃ©rer l'info du coverslip :
data <- mutate(data, coverslip =
unlist(map(data$Cell_id, function(x)
unique(df_clean[Cell_id == x,]$coverslip))))
tab2 <- data.frame(table(data$Start_peak_stimulus, data$group, data$coverslip))
# ENsuite crÃ©er une colonne correspondant au nombre de cellules non rÃ©pondeuses et la proportion de rÃ©pondeuse
group_list <- names(table(data$group))
stim_list <- names(table(data$Start_peak_stimulus))
coverslip_list <- names(table(data$coverslip))
# RÃ©cupÃ©rer le nombre de cellule par groupe :
n_cells <- map(group_list, function(x) rep(dim(table(filter(df_clean, group == x)$Cell_id))[1], each = length(stim_list)* length(coverslip_list)))
tab <- mutate(tab2, Not_Responding = unlist(map2(unlist(n_cells), tab2$Freq, function(x,y) x - y)),
Percent_Response = unlist(map2(tab2$Freq, unlist(n_cells), function(x,y) (x / y)*100)))
tab_final <- rename(tab, "Stimulus" = Var1 ,"Group"= Var2, "Coverslip" = Var3, "Responding" = Freq )
tab_list <- split(tab_final, tab_final$Coverslip)
tab_list <- lapply(tab_list, function(x) x[1:length(stim_list),])
tab_bis <- do.call(rbind, tab_list)
tab_bis$Group <- rep(group_list, each = length(stim_list))
#tab_bis <- filter(tab_final, Responding != 0)
write.csv(tab_bis, "tab_stim_by_group.csv")
return(list("TRUE", "Response_by_group_and_stim" = tab_bis))
}
guigui()
#' dual_prop
#'
#' @param data
#' @param stim1
#' @param stim2
#'
#' @return
#' @export
#'
#' @examples
dual_prop <- function(data, stim1, stim2){
#data$spike_stimulus <- str_replace_all(data$spike_stimulus, "[123456789.]", "")
#stim1 <- str_replace_all(stim1, "[123456789.]", "")
#stim2 <- str_replace_all(stim2, "[123456789.]", "")
data <- data.table::setDT(data)
data <- data[, Stim1 := spike_stimulus == stim1]
data <- data[, Stim2 := spike_stimulus == stim2]
n_cells_stim1 <- length(unique(data[data$Stim1 == TRUE, ]$Cell_id))
n_cells_stim2 <- length(unique(data[data$Stim2 == TRUE, ]$Cell_id))
# stocker les noms des stimuli :
stim <- unique(data$spike_stimulus)
# CrÃ©er le tableau de contingence avec les deux stimuli
df <- contingency(data)
# Filter cells responding to both stimuli
df_true <- dplyr::filter(df, Freq !=0 & Freq.1 !=0)
# Number of cells that responds to both stimuli
n_cells_tot <- dplyr::count(df_true)
# Number of cells responding to the first
n_cells_first <- dplyr::count(dplyr::filter(df, Freq != 0))
# Number of cells responding to the second
n_cells_second <- dplyr::count(dplyr::filter(df, Freq.1 != 0))
# Proportion of cells responding to both
prop1 <- n_cells_tot / length(data[["Stim1"]])
# Proportion of cells reponding to the first that also responds to the second :
prop2 <- n_cells_tot / n_cells_first
# Proportion of cells reponding to the second that also responds to the first :
prop3 <- n_cells_tot / n_cells_second
# creating a table with all these informations :
table_final <- data.table::data.table(n_legend = c(stim1, stim2, "Both_stimuli"), n_cells = c(n_cells_first, n_cells_second, n_cells_tot), Prop_legend =c(paste0("Both/", stim1), paste0("Both/", stim2), "Both/all"), props = c(prop2, prop3, prop1))
return(table_final)
}
#' contingency
#'
#' @param data
#'
#' @return
#' @export
#'
#' @examples
contingency <- function(data){
t_s1 <- as.data.frame(table(data$Cell_id, data$Stim1))
t_s1 <- dplyr::filter(t_s1, Var2 == TRUE)
t_s2 <- as.data.frame(table(data$Cell_id, data$Stim2))
t_s2 <- dplyr::filter(t_s2, Var2 == TRUE)
t_final <- as.data.frame(cbind(t_s1, t_s2))
# only keep cell_id once and freq for each stimulus
t_final <- t_final[,c(1,3,6)]
return(t_final)
}
#'
#' @param res1
#' @param stim_pos
#' @param res2
#' @param stim_pos2
#'
#' @return
#' @export
#'
#' @examples
compare_dual_prop <- function(res1, stim_pos, res2, stim_pos2) {
n_stim1 <- unlist(res1$n_cells[stim_pos])
n_stim2 <- unlist(res2$n_cells[stim_pos2])
x1 <- unlist(res1$n_cells[3])
x2 <- unlist(res2$n_cells[3])
res <- stats::prop.test(c(x1, x2), c(n_stim1, n_stim2))
return(res)
}
#' cross_prop.venn
#'
#' @param data
#' @param stim1
#' @param stim2
#'
#' @return
#' @export
#'
#' @examples
cross_prop.venn <- function(data, stim_list){
#data$spike_stimulus <- str_replace_all(data$spike_stimulus, "[123456789.]", "")
#stim_list <- str_replace_all(stim_list, "[123456789.]", "")
t <- data.table(table(data$spike_stimulus, data$Cell_id))
data <- lapply(stim_list, function(x) unique(t[t$N != 0 & t$V1 == x,]$V2))
names(data) <- stim_list
p <- ggvenn::ggvenn(data)
return(p)
}
#' dual_prop
#'
#' @param data
#' @param stim1
#' @param stim2
#'
#' @return
#' @export
#'
#' @examples
dual_prop <- function(data, stim1, stim2){
#data$spike_stimulus <- str_replace_all(data$spike_stimulus, "[123456789.]", "")
#stim1 <- str_replace_all(stim1, "[123456789.]", "")
#stim2 <- str_replace_all(stim2, "[123456789.]", "")
data <- data.table::setDT(data)
data <- data[, Stim1 := spike_stimulus == stim1]
data <- data[, Stim2 := spike_stimulus == stim2]
n_cells_stim1 <- length(unique(data[data$Stim1 == TRUE, ]$Cell_id))
n_cells_stim2 <- length(unique(data[data$Stim2 == TRUE, ]$Cell_id))
# stocker les noms des stimuli :
stim <- unique(data$spike_stimulus)
# CrÃ©er le tableau de contingence avec les deux stimuli
df <- contingency(data)
# Filter cells responding to both stimuli
df_true <- dplyr::filter(df, Freq !=0 & Freq.1 !=0)
# Number of cells that responds to both stimuli
n_cells_tot <- dplyr::count(df_true)
# Number of cells responding to the first
n_cells_first <- dplyr::count(dplyr::filter(df, Freq != 0))
# Number of cells responding to the second
n_cells_second <- dplyr::count(dplyr::filter(df, Freq.1 != 0))
# Proportion of cells responding to both
prop1 <- n_cells_tot / length(data[["Stim1"]])
# Proportion of cells reponding to the first that also responds to the second :
prop2 <- n_cells_tot / n_cells_first
# Proportion of cells reponding to the second that also responds to the first :
prop3 <- n_cells_tot / n_cells_second
# creating a table with all these informations :
table_final <- data.table::data.table(n_legend = c(stim1, stim2, "Both_stimuli"), n_cells = c(n_cells_first, n_cells_second, n_cells_tot), Prop_legend =c(paste0("Both/", stim1), paste0("Both/", stim2), "Both/all"), props = c(prop2, prop3, prop1))
return(table_final)
}
#' contingency
#'
#' @param data
#'
#' @return
#' @export
#'
#' @examples
contingency <- function(data){
t_s1 <- as.data.frame(table(data$Cell_id, data$Stim1))
t_s1 <- dplyr::filter(t_s1, Var2 == TRUE)
t_s2 <- as.data.frame(table(data$Cell_id, data$Stim2))
t_s2 <- dplyr::filter(t_s2, Var2 == TRUE)
t_final <- as.data.frame(cbind(t_s1, t_s2))
# only keep cell_id once and freq for each stimulus
t_final <- t_final[,c(1,3,6)]
return(t_final)
}
#'
#' @param res1
#' @param stim_pos
#' @param res2
#' @param stim_pos2
#'
#' @return
#' @export
#'
#' @examples
compare_dual_prop <- function(res1, stim_pos, res2, stim_pos2) {
n_stim1 <- unlist(res1$n_cells[stim_pos])
n_stim2 <- unlist(res2$n_cells[stim_pos2])
x1 <- unlist(res1$n_cells[3])
x2 <- unlist(res2$n_cells[3])
res <- stats::prop.test(c(x1, x2), c(n_stim1, n_stim2))
return(res)
}
#' cross_prop.venn
#'
#' @param data
#' @param stim1
#' @param stim2
#'
#' @return
#' @export
#'
#' @examples
cross_prop.venn <- function(data, stim_list){
#data$spike_stimulus <- str_replace_all(data$spike_stimulus, "[123456789.]", "")
#stim_list <- str_replace_all(stim_list, "[123456789.]", "")
t <- data.table(table(data$spike_stimulus, data$Cell_id))
data <- lapply(stim_list, function(x) unique(t[t$N != 0 & t$V1 == x,]$V2))
names(data) <- stim_list
p <- ggvenn::ggvenn(data)
return(p)
}
dual_prop_travaux <- function(data, stim_list){
data$spike_stimulus <- str_replace_all(data$spike_stimulus, "[123456789.]", "")
stim_list <- unique(str_replace_all(stim_list, "[123456789.]", ""))
data <- data.table::setDT(data)
data_list <- lapply(seq(1,length(stim_list)), function(x) data[, paste0("stim",x)
:= spike_stimulus == stim_list[x]] )
data <- data_list[[length(data_list)]]
n_resp_tot <- length(unique(data$Cell_id))
#n_cells_list <- lapply(seq(1,length(stim_list)), function(x)
# length(unique(data[data[[paste0("stim",x)]] == TRUE, ]$Cell_id)))
#n_cells_joint_resp <- lapply(seq(1,length(stim_list)), function(x)
#length(unique(data[data[[paste0("stim",x)]] == TRUE, ]$Cell_id)))
# CrÃ©er le tableau de contingence avec les deux stimuli
#f <- contingency(data)
t <- data.table(table(data$spike_stimulus, data$Cell_id))
data <- lapply(stim_list, function(x) unique(t[t$N != 0 & t$V1 == x,]$V2))
names(data) <- stim_list
print(data)
# Filter cells responding to both stimuli
print(data[stim_list])
n_cells_tot <- 1000
n_resp <- c(length(data[[1]]), length(data[[2]]))
dual_resp <- length(unlist(intersect(data[[1]], data[[2]])))
table_final <- data.table(n_resp, n_resp_tot, dual_resp )
rownames(table_final) <- c(stim_list[[1]], stim_list[[2]])
colnames(table_final) <- c("N_Responders", "N_Responders_Tot", "Common_Response")
return(table_final)
}
guigui()
