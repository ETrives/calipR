print(res_full$res[[3]][[2]][[1]])
print(str(res_full$res[[3]][[2]][[1]]))
res3_3_1 <- data.table::setDT(res_full$res[[3]][[2]][[1]])
calipR::saveData(res3_3_1, paste(project$dir_path,project$db_file, sep ="/"), "overall_q")
res3_3_2 <- data.table::setDT(res_full$res[[3]][[2]][[2]])
calipR::saveData(res3_3_2, paste(project$dir_path,project$db_file, sep ="/"), "pairwise")
}
})
# retrieving full dataset and peaks dataset :
result <- reactiveValues()
res <- shiny::eventReactive(input$update_button,{
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'df_final'"))[1] == 0) {
}
else{
path <- paste(project$dir_path,project$db_file, sep ="/")
print("path")
print(path)
full <- calipR::get_full_df(path, "df_final")
peaks <- calipR::get_full_df(path, "peak_res")
result$full <- full
result$peaks <- peaks
print("full")
print(full)
print("peaks")
print(peaks)
}
if(input$base_resp == TRUE){
peaks_wo_base <- data.table::setDT(calipR::base_resp.rm(result$peaks, result$full)[[1]])
full_wo_base <- data.table::setDT(calipR::base_resp.rm(peaks, full)[[2]])
res <- Analyze_Responses(peaks_wo_base, full_wo_base, var_list = input$grouping_var)
}
else{
print("yamako")
res <- Analyze_Responses(result$peaks, full, var_list = input$grouping_var)
}
print(res)
res
})
observeEvent(input$update_button, {
output$resp_count <- DT::renderDataTable({
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'stats_desc_final'"))[1] == 0) {}
else{
result$resp_desc <- res()[[1]]
DT::datatable({result$resp_desc},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
pageLength = 100,
c("copy", "csv")),
class = "display"
)
}
})
output$overall_q <- DT::renderDataTable({
# if(dim(calipR::checkTable("db_cq.sqlite", "'overall_q'"))[1] == 0) {}
# else{
result$general_model <- res()[[2]][[1]]
DT::datatable({result$general_model},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
#}
}
)
output$post_hoc_mcnemar <- DT::renderDataTable({
#        if(dim(calipR::checkTable("db_cq.sqlite", "'pairwise'"))[1] == 0) {}
#else{
result$pw_mcnemar <- res()[[2]][[2]]
DT::datatable({res()[[2]][[2]]},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
# }
})
### Computing dual proportions (proportion of cells responding to one stimulus that also responds to another stimulus)
output$stim_list_1 <- shiny::renderUI({
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'peak_res'"))[1] == 0) {}
else{
stim_list <- unique(result$peaks[["spike_stimulus"]])
shiny::selectInput(inputId = "stim_list_1", "Stimulus 1", stim_list)
}
})
output$stim_list_2 <- shiny::renderUI({
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'peak_res'"))[1] == 0) {}
else{
stim_list <- unique(result$peaks[["spike_stimulus"]])
shiny::selectInput(inputId = "stim_list_2", "Stimulus 2", stim_list)
}
})
t <- shiny::eventReactive(input$dual_button, {
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'peak_res'"))[1] == 0) {}
else{
g <- result$peaks
if(input$base_resp_dual == TRUE){
g <- calipR::base_resp.rm(result$peaks, result$full)[[1]]
}
print("input$stim_list_1")
print(input$stim_list_1)
t <- dual_prop(g, input$stim_list_1, input$stim_list_2)
}
})
output$dual_prop <- DT::renderDataTable(
DT::datatable({t()},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
))
})
### Ajouter des visualisations des pourcentages par groupe, par coverslip etc. :
output$var_selector <- shiny::renderUI({
list(
shiny::selectInput(inputId = "x_var", label = NULL, names(result$resp_desc)),
shiny::selectInput(inputId = "y_var", label = NULL, names(result$resp_desc)),
shiny::selectInput(inputId = "z_var", label = NULL, names(result$resp_desc))
)
})
output$viz <- plotly::renderPlotly({
print(res()[[1]])
print(str(res()[[1]]))
print("result$resp_desc")
print(result$resp_desc)
print("result$resp_desc[[input$x]]")
print(result$resp_desc[[input$x_var]])
print("result$resp_desc[[input$y]]")
print(result$resp_desc[[input$y_var]])
#res <- calipR::get_full_df("db_cq.sqlite", "stats_desc_by_cov_group")
plotly::plot_ly(
type = 'bar',
x = result$resp_desc[[input$x_var]],
y = result$resp_desc[[input$y_var]],
text = paste("Group: ", result$resp_desc[["group"]],
"<br>Stimulus:  ", res()[[1]][["stimulus"]],
"<br>Responders: ", res()[[1]][["Responses"]],
"<br>Proportion: ", res()[[1]][["Prop"]],
"<br> Total cells: ", res()[[1]][["n_cells_grp"]]),
hoverinfo = 'text',
marker = list(size = 2),
color = res()[[1]][[input$z_var]],
)  %>%
plotly::layout(barmode ="group", yaxis = list(automargin = TRUE),
xaxis = list(automargin = TRUE), bargap = -2, bargroupgap = 0)
})
output$resp_viz <- shiny::renderUI({
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'df_final'"))[1] == 0) {
}
else{
responders <- unique(result$peaks[["Cell_id"]])
shiny::selectInput(inputId = "resp_viz", "Responders", responders)
}
})
output$non_resp_viz <- shiny::renderUI({
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'df_final'"))[1] == 0) {
}
else{
cells <- unique(result$full[["Cell_id"]])
responders <- unique(result$peaks[["Cell_id"]])
non_responders <- cells %in% responders
non_responders <- unlist(purrr::map2(cells, non_responders, function(x,y) if(y == FALSE){x}))
shiny::selectInput(inputId = "non_resp_viz", "Non Responders", non_responders)
}
})
shiny::observeEvent(input$plot_button,{
cnames <- colnames(result$full)
print(cnames)
back_estim_opt <- c("gam_fit", "background")
cnames_check <- back_estim_opt %in% cnames
print(cnames_check)
back_var <- back_estim_opt[[which(cnames_check == TRUE)]]
output$plot_resp_viz <- renderPlot({
# OpÃ©rer un tri sur les cellules regarder comment j'ai fais pour responders
p <- cell_plot(result$full, result$peaks, var = "Mean_Grey", cell = input$resp_viz, line = back_var, show_peak = input$show_peaks_box)
p
})
})
shiny::observeEvent(input$plot_button_bis,{
cnames <- colnames(result$full)
print(cnames)
back_estim_opt <- c("gam_fit", "background")
cnames_check <- back_estim_opt %in% cnames
print(cnames_check)
back_var <- back_estim_opt[[which(cnames_check == TRUE)]]
output$plot_resp_viz <- renderPlot({
p <- cell_plot(result$full, result$peaks, var = "Mean_Grey", cell = input$non_resp_viz, line = back_var, show_peak = input$show_peaks_box)
p
})
})
output$clustering_var <- shiny::renderUI({
if(dim(calipR::checkTable(paste(project$dir_path,project$db_file, sep ="/"), "'df_final'"))[1] == 0) {
print( "dim == 0")
}
else{
list_var <- names(result$full)
#list_var <- names(res_full$res[[2]])
shiny::selectInput(inputId = "clustvar", "Variable used for clustering", list_var)
}
})
shiny::observeEvent(input$set_seed, {
if(input$set_seed){
output$seed_field <- shiny::renderUI({
shiny::textInput("seed", "Enter Seed Value")
})
}
else{
output$seed_field <- NULL
}
})
shiny::observeEvent(input$clustplot_button, {
responding_cells <- unique(result$peaks[["Cell_id"]])
print(responding_cells)
print("responding_cells")
print(result$full)
print("result$full")
print(unique(result$full[["Cell_id"]]))
print(length(unique(result$full[["Cell_id"]])))
dt <- result$full[Cell_id %in% responding_cells]
print("yout")
final <- prepareClustData(dt, input$clustvar, norm = input$normclust)
print("final")
print(final)
print(input$nclust)
print(input$dist_type)
if(input$set_seed){
set.seed(as.integer(input$seed))
}
clust_res <- dtwclust::tsclust(final, type = "partitional", k = as.integer(input$nclust), distance = input$dist_type,
centroid = "dba")
output$clustplot <- shiny::renderPlot({
p <- plot(clust_res, type="sc")
p
})
})
}
shiny::shinyApp(ui, server)
}
#' @param pattern_matching
#' @param posBank
#' @param negBank
#' @param windows
#' @param steps
#'
#' @return
#' @export
#'
#' @examples
downstream_analysis <- function(data, moving_thresh = 0.1, outlier_thresh = 2, mean_width = 20, DPA_width = 10, CN_DPA_width = 20,
mean_width_diff = 10, method = "gam", norm_var = "gam",
norm_width = 10, lambda = 100,
gam = 0.97, constraint = T, z_thresh = 3, delta_thresh = 0,
deconvolve_var = "gam_detrended", borders_range = 50,
time_thresh = 1, compare_groups = FALSE, false_pos = c(TRUE, FALSE), one_cell = FALSE, simulation = FALSE,
pattern_matching = FALSE, posBank = list(),
negBank = list(), windows = c(30,70,100), steps = c(5,10,50)) {
lambda <- as.numeric(lambda)
print(lambda)
gam <- as.numeric(gam)
print(gam)
#threshold <- as.numeric(threshold)
print(z_thresh)
#borders_range <- as.integer(borders_range)
#print(borders_range)
if(one_cell == FALSE){
shiny::withProgress(message = "Analyzing Full Dataset", value = 0, detail = "Cleaning Data", {
if(pattern_matching == TRUE){
clean <-clean_data(data, moving_thresh, outlier_thresh, mean_width,
CN_DPA_width, DPA_width, mean_width_diff, method = "back")
shiny::incProgress(1/5, detail = "Estimating Background")
back <- patDetectR(clean, windows, steps, new_len = 30, posBank,
negBank, Var = "Mean_Grey")
print("patdec ok" )
back <- backEstimatR(clean, back)
print("back ok" )
shiny::incProgress(1/5, detail = "Normalizing Data")
norm <- norm_df(back, var = "back", width = norm_width)
print("norm ok" )
shiny::incProgress(1/5, detail = "Performing Deconvolution")
deconvolved <- deconvolve(norm, lambda = lambda, gam = gam, constraint = constraint,
threshold = z_thresh, delta_threshold = delta_thresh, var = "background_detrended")
print("deconvolve ok" )
}
if(pattern_matching == FALSE){
clean <- clean_data(data, moving_thresh, outlier_thresh, mean_width,
CN_DPA_width, DPA_width, mean_width_diff)
print("cleaning = OK")
shiny::incProgress(1/5, detail = "Estimating Background")
back <- calipR::backEstimate(clean, method = method)
print("back = OK")
shiny::incProgress(1/5, detail = "Normalizing Data")
norm <- calipR::norm_df(back, var = norm_var, width = norm_width)
print("norm = OK")
print(norm)
shiny::incProgress(1/5, detail = "Performing Deconvolution")
deconvolved <- deconvolve(norm, lambda = lambda, gam = gam, constraint = constraint,
threshold = z_thresh, delta_threshold = delta_thresh, var = deconvolve_var)
}
print("deconvolved = ok")
print(deconvolved[[1]]$Cell_id)
print(deconvolved[[1]])
if(length(deconvolved[[1]]$Cell_id) != 0){
if(false_pos == TRUE){
shiny::incProgress(1/5, detail = "Removing Estimated False Positives")
deconvolved <- keep_best_peaks(deconvolved)
print("best = ok")
}
shiny::incProgress(1/5, detail = "Computing Statistics")
print(deconvolved[[1]])
res <- Analyze_Responses(deconvolved[[1]], clean, compare_groups = compare_groups,
one_cell = one_cell, simulation = simulation)
}
})
}
if(one_cell == TRUE){
shiny::withProgress(message = "Testing New Parameters", value = 0, detail = "Performing Deconvolution", {
if(pattern_matching == TRUE){
clean <- clean_data(data, moving_thresh, outlier_thresh, mean_width,
CN_DPA_width, DPA_width, mean_width_diff, method = "back")
back <- patDetectR(clean, windows, steps, new_len = 30, posBank,
negBank, Var = "Mean_Grey")
back <- backEstimatR(clean, back)
norm <- norm_df(back, var = "back", width = norm_width)
deconvolved <- deconvolve(norm, lambda = lambda,gam = gam,
constraint = constraint,threshold = z_thresh,
delta_threshold = delta_thresh,
var = "background_detrended")
}
if(pattern_matching == FALSE){
clean <- clean_data(data, moving_thresh, outlier_thresh, mean_width,
CN_DPA_width, DPA_width, mean_width_diff)
back <- backEstimate(clean, method = method)
print("back = OK")
norm <- norm_df(back, var = norm_var, width = norm_width)
print("norm = OK")
print(norm)
deconvolved <- deconvolve(norm, lambda = lambda, gam = gam, constraint = constraint,
threshold = z_thresh, delta_threshold = delta_thresh,
var = deconvolve_var)
}
print("deconvolved :")
print(deconvolved)
print("deconvolved = ok")
print(deconvolved[[1]]$Cell_id)
if(length(deconvolved[[1]]$Cell_id) != 0){
if(false_pos == TRUE){
deconvolved <- keep_best_peaks(deconvolved)
print(deconvolved)
#else{
#shiny::incProgress(1/2, detail = "Finding Peaks Borders")
#borders <- calipR::find_borders(best, range = borders_range)
#}
}
#if(false_pos == FALSE){
#shiny::incProgress(1/2, detail = "Finding Peaks Borders")
#borders <- calipR::find_borders(deconvolved, range = borders_range)
#}
}
res <- "NO RES"
norm <- data
})
}
print("finished Downstream analysis")
print(deconvolved)
print("YEAH new one !")
return(list(deconvolved[[1]], deconvolved[[2]], res))
}
launch_GuiGui_bis()
#' @param mean_width
#' @param DPA_width
#' @param CN_DPA_width
#' @param mean_width_diff
#' @param data a data.table output from prepareData function
#'
#' @return
#' @export
#'
#' @examples ## the one that is working !!! (function clean data below is not)
clean_data <- function(data, moving_threshold, outlier_threshold ,mean_width,
CN_DPA_width, DPA_width, mean_width_diff, method = "DPA") {
ncells_before <- length(unique(data$Cell_id))
print(paste("Number of cells before cleaning", ncells_before, sep = ": " ))
# Removing Cells with too much Nas :
na_sum <- data.table::setDT(data)[, .(NA_sum = sum(is.na(get("Mean_Grey")))), by = Cell_id ]
print("na_sum")
print(na_sum)
frame_sum <- data[, .(frame_sum = length(get("Mean_Grey"))), by = Cell_id ]
print("frame_sum")
print(frame_sum)
na_ratio <- na_sum$NA_sum / frame_sum$frame_sum
print("frame_sum")
print(frame_sum)
data$na_ratio <- unlist(purrr::map2(na_ratio, frame_sum$frame_sum, function(x,y)
rep(x,times = y)))
print(data$na_ratio)
# Removing cells that moved too much (fluorescence down to zero)
zero_sum <- data[, .(zero_sum = sum((get("Mean_Grey") == 0))), by = Cell_id ]
zero_ratio <- zero_sum$zero_sum / frame_sum$frame_sum
data$zero_ratio <- unlist(purrr::map2(zero_ratio, frame_sum$frame_sum, function(x,y)
rep(x,times = y)))
data <- data[zero_ratio < moving_threshold & na_ratio < moving_threshold]
# Computing a local mean for each data.table
local_mean_fct <- function(x,y,z) gplots::wapply(x, y, fun = mean, n=length(z), width = mean_width, method = "nobs")[[2]]
data <- data[, local_mean := data[, .(local_mean = local_mean_fct(get("time_frame"), get("Mean_Grey"), get("time_frame"))), by = Cell_id]$local_mean]
data <- data[, Mean_Grey := data[, .(Mean_Grey = replace(get("Mean_Grey"), get("time_frame") == 1
& get("Mean_Grey") == 0, get("local_mean")[1])), by = Cell_id]$Mean_Grey]
# Computing first derivative
first_d_fct <- function(x,y) doremi::calculate.gold(time = x, signal = y,
embedding = 2, n = 1)$dsignal[,2]
data <- data[, first_derivative := data[, .(first_derivative = first_d_fct(get("time_seconds"), get("local_mean"))), by = Cell_id]$first_derivative]
local_mean_diff_fct <- function(x,y,z) gplots::wapply(x, y, fun = mean, n=length(z), width = mean_width_diff, method = "nobs", drop.na = FALSE)[[2]]
data <- data[, smooth_Diff := data[, .(smooth_Diff = local_mean_diff_fct(get("time_frame"), get("first_derivative"), get("time_frame"))), by = Cell_id]$smooth_Diff]
if(method == "DPA") {
cell_split <- split(data, data$Cell_id)
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[, c("DPA", "CN_DPA") := list(DPA(x, DPA_width),  CN_DPA(x, CN_DPA_width))])
print("DPA DOOONE")
print("CN_DPA DOOONE")
cell_split <- lapply(cell_split, function(x) x[, c("DPA", "CN_DPA") :=
list(replace(DPA, is.na(DPA),quantile_speed(DPA, probs = .5)),
replace(CN_DPA, is.na(CN_DPA), quantile_speed(CN_DPA, probs = .5)))])
cell_split <- lapply(cell_split, function(x) data.table::setDT(x)[,
c("smooth_DPA", "smooth_CN_DPA") := list(gplots::wapply(x$time_frame, x$DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]],
gplots::wapply(x$time_frame, x$CN_DPA, fun = mean, n=length(x$time_frame), width = 10, method = "nobs")[[2]])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, smooth_Diff > 1 |
smooth_DPA > quantile_speed(smooth_DPA, probs = .7, na.rm = T)|
smooth_CN_DPA > quantile_speed(smooth_CN_DPA, probs = .7, na.rm = T)|
Mean_Grey < (mean(Mean_Grey) - 1.5*stats::sd(Mean_Grey)),
NaN)])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == max(time_frame) & is.na(Mean_Grey_wo_peaks), local_mean[ max(time_frame)])])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey_wo_peaks, time_frame == 1 & is.na(Mean_Grey_wo_peaks), local_mean[1])])
lapply(cell_split, function(x) if(length(is.na(x$Mean_Grey_wo_peaks)[is.na(x$Mean_Grey_wo_peaks)[TRUE]]) == length(x$Mean_Grey_wo_peaks)) {print(x)})
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := approxfun(which(!is.na(Mean_Grey_wo_peaks)), na.omit(Mean_Grey_wo_peaks))(seq_along(Mean_Grey_wo_peaks))])
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := gplots::wapply(x$time_frame, x$Mean_Grey_wo_peaks,
fun = function(x) quantile_speed(x, probs = .1), n = length(x$time_frame), width = 30, method = "nobs")[[2]]])
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
cell_split <- split(data, data$Cell_id)
data <- lapply(cell_split, function(x) data.table::setDT(x)[, Anormal_variation := LaplacesDemon::is.bimodal(Mean_Grey)])
data <- do.call(rbind, cell_split)
}
print(paste("Number of cells after cleaning", length(unique(data$Cell_id)), sep = ": " ))
print(paste("Removed", ncells_before - length(unique(data$Cell_id)), "cells", sep = " " ))
print(data)
return(data)
}
launch_GuiGui_bis()
library(proxy)
launch_GuiGui_bis()
if (!require("ggplot")) install.packages("ggplot")
if (!require("ggplot2")) install.packages("ggplot2")
!require("ggplot2")
require("ggplot2")
?require
x <- require("ggplot2")
x
x <- !require("ggplot2")
x
if (!require("devtools")) install.packages("devtools")
library(calipR)
launch_GuiGui_bis()
launch_GuiGui_bis()
1.33*1000
(1.33*1000):1
(1.33*1000)/1
x <-10*10^12
x
y <- 10*10^9
y
z <- 1*10^7
1.33*z
install.packages("badgecreatr")
session.info()
sessionInfo()
use_gpl3_license()
?proxy
??proxy
proxy::pr_DB$get_entry_name()
sessioninfo::package_info(pkgs = "installed")
source("~/Git/calipR/R/launch_GuiGui.R", echo=TRUE)
source("~/Git/calipR/R/launch_GuiGui.R", echo=TRUE)
source("~/Git/calipR/R/launch_GuiGui.R", echo=TRUE)
source("~/Git/calipR/R/launch_GuiGui.R", echo=TRUE)
sessionInfo
sessionInfo()
devtools::check()
