mean(x$Mean_Grey),TRUE, FALSE)])
print("noise = ok")
cell_split <- lapply(cell_split, function(x) x[, noise := replace(noise, time_frame == max(time_frame), TRUE)])
cell_split <-  lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := replace(Mean_Grey, signal == TRUE & noise == FALSE,NaN)])
cell_split <- lapply(cell_split, function(x) x[, Mean_Grey_wo_peaks := approxfun(which(!is.na(Mean_Grey_wo_peaks)), na.omit(Mean_Grey_wo_peaks))(seq_along(Mean_Grey_wo_peaks))])
data <- do.call(rbind, cell_split)
data$Mean_Grey_wo_peaks[which(is.na(data$Mean_Grey_wo_peaks))] <- data$local_mean[which(is.na(data$Mean_Grey_wo_peaks))]
print("mean_grey wo peaks ok")
cell_split <- split(data, data$Cell_id)
if(method == "smooth"){
cell_split  <- lapply(cell_split , function(x) x[, gam_fit := gplots::wapply(x$time_frame, x$Mean_Grey_wo_peaks, fun = mean, n=length(x$time_frame), width = smooth, method = "nobs")[[2]]])
cell_split <- lapply(cell_split, function(x) x[, gam_detrended := Mean_Grey - gam_fit])
}
if(method == "gam"){
cell_split <- lapply(cell_split, function(x) x[, gam_fit := mgcv::gam(Mean_Grey_wo_peaks ~ s(time_frame, bs = "cr", k = 11), data = x, gamma = 2)[[3]]])
cell_split <- lapply(cell_split, function(x) x[, gam_detrended := Mean_Grey - gam_fit])
}
data <- do.call(rbind, cell_split)
print("ok")
return(data)
}
launch_GuiGui()
library(calipR)
library(calipR)
launch_GuiGui()
launch_GuiGui()
#' launch_GuiGui
#'
#' Exectue this function without any argument to launch the Graphical User Interface (GUI)
#'
#'
#' @return
#' @export
#'
#' @examples
launch_GuiGui <- function(){
ui <-
shinydashboard::dashboardPage(skin = "blue",
calipR::dashboardHeader(disable = TRUE),
shinydashboard::dashboardSidebar(
shiny::tags$head(
shiny::tags$style(shiny::HTML(".sidebar {
height: 100%;
}"
)
)
),
shiny::img(src = "logo/calipR_logo.png", width = "70%", height = "70%",
style = "position: relative; top: -30px; left: 30px;"),
#shiny::tags$style(".left-side, .main-sidebar {padding-top: 180px}"),
shinydashboard::sidebarMenu(id = "sidebarid",
shinydashboard::menuItem(
"Description", tabName = "des"),
shinydashboard::menuItem(
"Tutorial", tabName = "tuto"),
shinydashboard::menuItem(
"Analyze Your Data", tabName = "ana"),
shinydashboard::menuSubItem("Prepare Data", tabName = "prep"),
shinydashboard::menuSubItem("Visualize Raw Data", tabName = "viz"),
shinydashboard::menuSubItem("Optimize Analysis Parameters", tabName = "opt"),
shinydashboard::menuSubItem("Analyze data", tabName = "ana_full"),
shinydashboard::menuSubItem("Visualize Results", tabName = "viz_res"),
shiny::conditionalPanel( 'input.sidebarid == "prep"',
shiny::selectInput("stim_num", label ="Stimuli number (/cell)", c("1" = "1", "2" = "2", "3" = "3",
"4" = "4", "5" = "5", "6"="6", "7"="7",
"8"="8", "9"="9","10"="10")),
shiny::textInput("frame_rate", label = "Enter your frame rate (Hz)", placeholder = "e.g. 0.5" ),
shiny::textInput("folder", label = NULL, placeholder = "Write folder's name (where all the files are)"),
shiny::actionButton("launch", "Load & Tidy Data", align = "center")),
shiny::conditionalPanel( 'input.sidebarid == "viz"',
),
shiny::conditionalPanel( 'input.sidebarid == "ana_full"',
shiny::textInput("peak_thresh_full", label = "Peak Threshold", placeholder = "Peak Threshold"),
shiny::textInput("rise_full", label = "Borders Range", placeholder = "Frame before peak"),
shiny::textInput("lambda_full", label = "Lambda"),
shiny::textInput("gam_full", label = "gam"),
shiny::checkboxInput("false_pos_full", label = "False Positives Estimation"),
shiny::checkboxInput("groups", label = "Compare groups"),
shiny::actionButton("ana_full_button", "Launch Full Analysis", align = "center"))
)),
shinydashboard::dashboardBody(
shiny::tags$head(shiny::tags$style(shiny::HTML("
/* main sidebar */
.skin-blue .main-sidebar {
background-color: #172330;
}
/* active selected tab in the sidebarmenu */
.skin-blue .main-sidebar .sidebar .sidebar-menu .active a{
background-color: #5499c7
}
"))),
shinydashboard::tabItems(
shinydashboard::tabItem("des",
shiny::fluidRow(
shiny::img(src = "logo/calipR_logo.png",
style = "border: 1px;
color: white;
position: absolute;
top : 100px;
left: 300px;
right: 0;
margin: 0 auto;
max-width: 250px;"), shiny::div(style = "height:1000px;")),
shiny::fluidRow(
shiny::HTML( "<center> <p style = 'font-size: 20px; word-wrap: break-word;
width: 1000px; align: justify; color: black; padding-top: 50px;
position: absolute;
top: 400px;
left: 250px;
right: 0;
margin: 0 auto;
max-width: 600px;'> <b> calipR </b> is an open source software designed to facilitate calcium imaging data analysis.
It is fully written in the R programming language.
With this Graphical User Interface (GUI) you can analyze your data
without any programming skills.<br> <br>
Two workflows are available: one that allows you to automatize
ROIs detection with the Trackmate imageJ plugin and another
one that takes the output from manual ROI detection in ImageJ.
To start with your first analysis you can go on to the Tutorial page.</p> </center>"),
),
shiny::fluidRow(shiny::tags$br()),
shiny::fluidRow(shiny::tags$br()),
shiny::fluidRow(shiny::tags$br()),
),
shinydashboard::tabItem("ana", shiny::fluidRow(shiny::div(style = "height:1000px;"))),
shinydashboard::tabItem("tuto", shiny::fluidRow(shiny::div(style = "height:1000px;"))),
shinydashboard::tabItem("prep",
shiny::tags$style(shiny::HTML("
.box.box-solid.box-primary>.box-header {
color:#fff;
background:#5499c7
}
.box.box-solid.box-primary{
border-bottom-color:#5499c7  ;
border-left-color:#5499c7  ;
border-right-color:#5499c7  ;
border-top-color:#5499c7  ;
}
.box.box-primary>.box-header {
color:#000000;
background:#fff
}
.box.box-primary{
border-bottom-color:#5499c7  ;
border-left-color:#5499c7  ;
border-right-color:#5499c7  ;
border-top-color:#5499c7  ;
}
")),
shiny::fluidRow(class = "myRow1",
shiny::column(12,
shinydashboard::box(title = "Dataset Prepared", width = 12, solidHeader = TRUE, status = "primary", collapsible = T,
DT::dataTableOutput("df_sql")),
shiny::div(style = "height:1000px;")))),
shinydashboard::tabItem("viz",
shiny::fluidRow(
shinydashboard::box(title = "Plotting Cells", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("cell", label = NULL, placeholder = "Enter the name of the cell you want to plot"),
shiny::actionButton("cell_click", "Plot Cell", align = "center"),
shiny::plotOutput(outputId = "plot_cell")), shiny::div(style = "height:1000px"))),
shinydashboard::tabItem("opt",
shiny::fluidRow(
shinydashboard::box(title = "Optimize Parameters", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("peak_thresh", label = "Peak Threshold", placeholder = "Enter the peak threshold you want to try (z score)"),
shiny::textInput("rise_range", label = "Range", placeholder = "Enter the range taken to find a peak start (integer between 5 and 60)"),
shiny::textInput("lambda", label = "Lambda", placeholder = "Enter the Lambda parameter for the Deconvolution (integer)"),
shiny::textInput("gam", label = "Gam", placeholder = "Enter the Gam parameter for the Deconvolution (double between 0-1)"),
shiny::textInput("n_cells", label = "Number of cells", placeholder = "Enter the number of cells you want to run the stimulation on"),
shiny::checkboxInput("false_pos", label = "Estimate False Positives"),
shiny::checkboxInput("show_peak", label = "Show Peaks"),
shiny::uiOutput('responders'),
shiny::uiOutput('non_responders'),
shiny::actionButton("sim", "Simulate Analysis", align = "center"),
shiny::actionButton("plot_responders", "Plot Responder", align = "center"),
shiny::actionButton("plot_non_responders", "Plot Non Responder", align = "center")),
shinydashboard::box(title = "Try other parameters on a given cell", width = 6, solidHeader = TRUE, status = "primary",
shiny::textInput("cell_opt", label = "Cell", placeholder = "On which cell do you want to try new parameters ?"),
shiny::textInput("peak_thresh_bis", label = "Threshold", placeholder = "Enter the peak threshold you want to try (z score)"),
shiny::textInput("rise_range_bis", label = "Range", placeholder = "Enter the range taken to find a peak start (integer between 5 and 60)"),
shiny::textInput("lambda_bis", label = "Lambda", placeholder = "Enter the Lambda parameter for the Deconvolution (integer)"),
shiny::textInput("gam_bis", label = "Gam", placeholder = "Enter the Gam parameter for the Deconvolution (double between 0-1)"),
shiny::checkboxInput("false_pos_bis", label = "Estimate False Positives"),
shiny::checkboxInput("show_peak_bis", label = "Show Peaks"),
shiny::actionButton("sim_bis", "Simulate Analysis", align = "center"),
shiny::actionButton("plot_simulation_bis", "Plot Cell", align = "center"))),
shiny::fluidRow(
shinydashboard::box(title = "Plot Window", width = 6, solidHeader = TRUE, status = "primary",
shiny::plotOutput(outputId = "plot_cell_sim")),
shinydashboard::box(title = "Plot Window", width = 6, solidHeader = TRUE, status = "primary",
shiny::plotOutput(outputId = "plot_cell_sim_bis"))),
shiny::fluidRow(
shinydashboard::box(title = "Statistics", width = 6, solidHeader = TRUE, status = "primary",
DT::dataTableOutput("stats_opt")))),
shinydashboard::tabItem("ana_full",
shiny::fluidRow(
shinydashboard::box(title = "Description of Responses", width = 12, solidHeader = TRUE, status = "primary",
shinycssloaders::withSpinner(DT::dataTableOutput("resp_count"), type = 6),
DT::dataTableOutput("resp_group_stim"),
DT::dataTableOutput("peaks_by_class"),
DT::dataTableOutput("overall_q"),
DT::dataTableOutput("post_hoc_mcnemar")
)),
shiny::fluidRow(
shinydashboard::box(title = "Dual Proportions", width = 12, solidHeader = TRUE, status = "primary",
shiny::uiOutput("stim_list_1"),
shiny::uiOutput("stim_list_2"),
shiny::actionButton("dual_button", "Compute Dual Proportions", align = "center" ),
shiny::br(),
shiny::br(),
DT::dataTableOutput("dual_prop")),shiny::div(style = "height:1000px;"))),
shinydashboard::tabItem("viz_res",
shiny::fluidRow(
shinydashboard::box(title = "Plotting Cells", width = 12, solidHeader = TRUE, status = "primary",
shiny::selectInput(inputId = "x", label = NULL, list("Group" = "Group", "Coverslip" = "Coverslip", "Stimulus" = "Stimulus")),
shiny::selectInput(inputId = "y", label = NULL, list("Proportion" = "Proportion", "Responses" = "Responses")),
shiny::selectInput(inputId = "z", label = NULL, list("Group" = "Group", "Coverslip" = "Coverslip", "Stimulus" = "Stimulus")),
plotly::plotlyOutput(outputId = "viz")),shiny::div(style = "height:1000px;")))
)))
server <- function(input, output){
sqlitePath <- getwd()
folder <- shiny::reactive({
if(is.null(input$folder)) {return()}
else{
folder <- input$folder
folder
}
})
stim_numb <- shiny::reactive({
if(is.null(input$stim_num)) {return()}
else{
stim_numb <- as.numeric(input$stim_num)
stim_numb
}
})
df_final <- shiny::eventReactive(input$launch, {
df <- calipR::prepareData(folder(), stim_numb(), as.numeric(input$frame_rate), compare_groups = TRUE)
calipR::saveData(df, "db_cq.sqlite", "df_full")
df
})
output$df_sql <- DT::renderDataTable({
if(is.null(df_final())) {return()}
else{
df <- calipR::loading100("db_cq.sqlite", "df_full")
df <- DT::datatable(df)
df
}
})
df_plot <- shiny::eventReactive(input$cell_click, {
df <- calipR::get_cell(input$cell, "db_cq.sqlite", "df_full")
df
})
output$plot_cell <- shiny::renderPlot({
p <- calipR::cell_plot_shiny(df_plot())
p
})
res_sim <- shiny::reactiveValues(res = NULL)
shiny::observeEvent(input$sim, {
print("Simulation started")
df_sub <- calipR::get_sub_df("db_cq.sqlite", "df_full", input$n_cells)
res_sim$res <- calipR::downstream_analysis(df_sub, threshold = input$peak_thresh,
borders_range = input$rise_range, lambda = input$lambda, gam = input$gam,
false_pos = input$false_pos)
})
if(is.null(res_sim)){
}
else{
output$responders <- shiny::renderUI({
data <- res_sim$res
responders <- unique(data[[1]]$Cell_id)
shiny::selectInput(inputId = "responders", "Responders", responders)
})
}
if(is.null(res_sim)){
}
else{
output$non_responders <- shiny::renderUI({
data <- res_sim$res
cells <- unique(data[[2]]$Cell_id)
responders <- unique(data[[1]]$Cell_id)
non_responders <- cells %in% responders
non_responders <- unlist(purrr::map2(cells, non_responders, function(x,y) if(y == FALSE){x}))
shiny::selectInput(inputId = "non_responders", "Non Responders", non_responders)
})
}
if(is.null(res_sim)){
}
else{
output$stats_opt <- DT::renderDataTable({
data <- res_sim$res
res2 <- data[[3]][[2]]
res2
})
}
shiny::observeEvent(input$plot_responders, {
data <- res_sim$res
output$plot_cell_sim <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$responders, line = "gam", show_peak = input$show_peak)
p
})
})
shiny::observeEvent(input$plot_non_responders, {
data <- res_sim$res
output$plot_cell_sim <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$non_responders,
line = "gam", show_peak = input$show_peak)
p
})
})
shiny::observeEvent(input$sim_bis, {
print("second stim started")
df <- res_sim$res[[2]]
print("df ok ")
df_sub_bis <- df[df$Cell_id == input$cell_opt]
print("df_sub ok")
res_sim$res_bis <- calipR::downstream_analysis(df_sub_bis, threshold = input$peak_thresh_bis,
borders_range = input$rise_range_bis, lambda = input$lambda_bis,
gam = input$gam_bis, false_pos = input$false_pos_bis, one_cell = TRUE)
})
shiny::observeEvent(input$plot_simulation_bis, {
data <- res_sim$res_bis
output$plot_cell_sim_bis <- shiny::renderPlot({
p <- cell_plot(data[[2]], data[[1]], var = "Mean_Grey", cell = input$cell_opt, line = "gam", show_peak = input$show_peak_bis)
p
})
})
### Analyze the full dataset
# This block makes the check box "compare groups" reactive
shiny::observe({
group_value <- input$groups
shiny::updateCheckboxInput(shiny::getDefaultReactiveDomain(), "groups", value = group_value)
})
### This block codes alows to launch the analysis when the button analyze dataset is clicked on. It runs the whole analysis, on the whole dataset
res <- shiny::eventReactive(input$ana_full_button, {
df_full <- calipR::get_full_df("db_cq.sqlite", "df_full")
res <- calipR::downstream_analysis(df_full, threshold = input$peak_thresh_full,
borders_range = input$rise_full, lambda = input$lambda_full, gam = input$gam_full,
false_pos = input$false_pos_full, compare_groups = input$groups)
# Extracting and saving the data table containing one row for each peak with the informations
#about the peak
res1 <- res[[1]]
print("res1")
print(res1)
calipR::saveData(res1, "db_cq.sqlite", "peak_res")
# Extracting and saving the full data table updated
res2 <- res[[2]]
print("res2")
print(res2)
calipR::saveData(res2, "db_cq.sqlite", "df_final")
res3 <- res[[3]][[2]]
print("res3")
print(res3)
print(str(res3))
res3 <- data.table::setDT(res3)
print(res3)
print(str(res3))
calipR::saveData(res3, "db_cq.sqlite", "stats_desc_final")
print("res3 done")
res
})
output$resp_count <- DT::renderDataTable({
res <- res()
res1 <- res[[3]][[1]]
DT::datatable({res1},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
})
output$resp_group_stim <- DT::renderDataTable({
res <- res()
res2 <- res[[3]][[2]]
DT::datatable({res2},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
})
output$overall_q <- DT::renderDataTable({
res <- res()
if(is.character(res[[3]][[3]][[1]])) {
}
else{
res3 <- res[[3]][[3]][[1]]
DT::datatable({res3},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
}
}
)
output$post_hoc_mcnemar <- DT::renderDataTable({
res <- res()
if(is.character(res[[3]][[3]][[1]])) {
}
else{
res4 <- res[[3]][[3]][[2]]
DT::datatable({res4},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
)
}
})
### Computing dual proportions (proportion of cells responding to one stimulus that also responds to another stimulus)
output$stim_list_1 <- shiny::renderUI({
res <- get_full_df("db_cq.sqlite", "peak_res")
stim_list <- unique(res$Start_peak_stimulus)
shiny::selectInput(inputId = "stim_list_1", "Stimulus 1", stim_list)
})
output$stim_list_2 <- shiny::renderUI({
res <- get_full_df("db_cq.sqlite", "peak_res")
stim_list <- unique(res$Start_peak_stimulus)
shiny::selectInput(inputId = "stim_list_2", "Stimulus 2", stim_list)
})
t <- shiny::eventReactive(input$dual_button, {
res <- get_full_df("db_cq.sqlite", "peak_res")
t <- dual_prop(res, input$stim_list_1, input$stim_list_2)
})
output$dual_prop <- DT::renderDataTable(
DT::datatable({t()},
extensions = 'Buttons',
options = list(
paging = TRUE,
searching = TRUE,
fixedColumns = TRUE,
autoWidth = TRUE,
ordering = TRUE,
dom = 'tB',
c("copy", "csv")),
class = "display"
))
### Ajouter des visualisations des pourcentages par groupe, par coverslip etc. :
output$viz <- plotly::renderPlotly({
res <- get_full_df("db_cq.sqlite", "stats_desc_final")
plotly::plot_ly(
type = 'box',
x = res[[input$x]],
y = res[[input$y]],
text = paste("Group: ", res$Group,
"<br>Stimulus:  ", res$Stimulus,
"<br>Responders: ", res$Responses,
"<br>Proportion: ", res$Proportion,
"<br> Total cells: ", res$n_cells),
hoverinfo = 'text',
mode = 'markers',
boxpoints = "all",
jitter = 0.3,
pointpos = 0,
marker = list(size = 9, color = "black"),
color = res[[input$z]],
) %>%
plotly::layout(boxmode ="group", yaxis = list(automargin = TRUE),
xaxis = list(automargin = TRUE), boxgap = -2, boxgroupgap = 0)
})
}
shiny::shinyApp(ui, server)
}
launch_GuiGui()
library(calipR)
library(calipR)
launch_GuiGui()
library(calipR)
launch_GuiGui()
load("C:/Users/etrives/Documents/Git/calipR/.RData")
View(model_0)
full_d_resp_tot
noisewflow
noise_wflow
summary(noise_wflow)
noise_rec
data_rec
summary(data_rec)
library(calipR)
library(tidymodels)
launch_GuiGui()
library(calipR)
library(calipR)
launch_GuiGui()
library(calipR)
launch_GuiGui()
library(calipR)
launch_GuiGui()
library(calipR)
