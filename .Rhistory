}
else{
window <- windows
new_len <- 30
}
# Extending the trace so that patterns in its end can be fully screened with large
# windows :
dt <- dt[, rbind(.SD,.SD[rep(.N, max(window)),]), by = Cell_id]
# Computing steps for rolling subsequencing:
step <- as.integer(sqrt(window))* 2
# Subsequencing, Interpolation and Normalization
data <- subinoR(dt, window, step, new_len, posBank, negBank, var = Var, norm = Norm)
# DTW distance computing between each subsequence and each pattern
pos <- distcomputR(data[[2]], data[[1]], step, window)
neg <- distcomputR(data[[3]], data[[1]], step, window)
# Median distance extraction by index and Ratio between pos and neg median dist
res <- mdRatio(pos, neg)
return(res)
}
launchPipe <- function(data = NULL, path_to_file = "test1", rate = 1,thresh = 3, lam = 1000,
ga = 0.90, back_method = "back", roll_mean_width = 150,
rolling_pct_width = 50,pos_bank,neg_bank, windows, new_length = 30,
reference = "baseline"){
#pos_bank <- readRDS("projects/test1/pos_increased")
#neg_bank <- readRDS("projects/test1/neg_increased")
if(is.null(data)){
data <- prepareData(path_to_file, frame_rate = rate, duration_in_seconds = 30)
}
# Nouvel algo
if(back_method == "back"){
clean_data <- clean_data(data, method = "back", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10)
back_data <- patDetectR(clean_data, pos_bank, neg_bank,
Var = "Mean_Grey")
print("first back ok")
back_data_bis <- backEstimatR(clean_data,back_data)
print("entering norm")
norm_data <- norm_df(back_data_bis, var = "back", width = 10)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "background_detrended",
lambda = lam, gam = ga)
print("finishing")
}
if(back_method == "mean_10"){
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
back_data[, median_10s_before := median(.SD[time_frame %in% seq(110,120)]$Mean_Grey, na.rm = TRUE), by = Cell_id]
back_data[, mean_median := mean(.SD[time_frame %in% seq(110,120) & Mean_Grey <= median_10s_before]$Mean_Grey , na.rm = TRUE), by = Cell_id]
back_data[, gam_detrended := Mean_Grey - mean_median, by = Cell_id]
norm_data <- norm_df(back_data, var = "gam", width = 10, reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
deconvolve_data[[2]]$mean_median10 <- back_data$mean_median
}
if(back_method == "roll_mean"){
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
back_data[, rolling_mean := gplots::wapply(time_frame, Mean_Grey,fun = mean,
n = length(time_frame),  width = roll_mean_width, method = "nobs")[[2]], by = Cell_id]
back_data[, gam_detrended := Mean_Grey - rolling_mean, by = Cell_id]
norm_data <- norm_df(back_data, var = "gam", width = 10,reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
deconvolve_data[[2]]$rolling_mean <- back_data$rolling_mean
}
if(back_method == "roll_pct"){
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
back_data <- rolling_pct(back_data, rolling_pct_width, pct_lower =0.1, pct_upper =0.4, it = seq(1,2))
back_data[, gam_detrended := Mean_Grey - Mean_Grey2, by = Cell_id]
norm_data <- norm_df(back_data, var = "gam", width = 10,reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
deconvolve_data[[2]]$rolling_pct <- back_data$Mean_Grey2
}
if(back_method == "DPA") {
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
norm_data <- norm_df(back_data, var = "gam", width = 10, reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
print("finishing")
}
return(deconvolve_data)
}
res_max_v1.0.0_auto_win <- ROC_pipe(dt = data,pos = pos_max, neg = neg_max, manual = manual,
manual_adjusted=manual_adjusted, reference = "baseline")
set.seed(123)
res_robustness_max_v1.0.0_auto_win <- lapply(seq(0, 50), function(x)
precision_recall(add_weird_cells(res_max_v1.0.0_auto_win[[1]],
false_pos, x), var = 'auto_var', by = "stimulus"))
max_v1.0.0_auto_win <- extracting_data_for_plot(list(res_robustness_max_v1.0.0_auto_win),
plage = c(1:1), pct = pct, combination_increment = 15,
mean = FALSE)
max_v1.0.0_auto_win$combination <- factor(max_v1.0.0_auto_win$combination, levels = c("16"))
ggplot(data = max_v1.0.0_auto_win ,aes(x=mean_Recall,y=mean_Precision))+
geom_line(aes(group = combination,color=combination),size = 1)+
geom_point(aes(group = combination,color=combination),size = 1)+
scale_color_viridis_d(option = "D")+
facet_wrap(~percent_noise)+
ylim(c(0,1))+
xlim(c(0,1))+
theme_bw()
View(mdRatio)
View(distcomputR)
library(calipR)
guigui()
View(calipR::peakExtractR)
View(calipR::peakExtractR)
View(calipR::distcomputR)
View(calipR::patDetectR())
View(calipR::patDetectR
)
#' @param posBank
#' @param negBank
#' @param new_len
#' @param Var
#' @param Norm
#'
#' @return A data table containing the ratio for each index and related informations
#' @export
#'
#' @examples
patDetectR <- function(dt, posBank, negBank, Var, Norm = TRUE, windows = NULL) {
if(is.null(windows)){
posBank<-posBank[!sapply(posBank,is.null)]
negBank<-negBank[!sapply(negBank,is.null)]
max_window <- max(unlist(lapply(posBank, length)), na.rm = TRUE)
min_window <- min(unlist(lapply(posBank, length)), na.rm = TRUE)
max_window_neg <- max(unlist(lapply(negBank, length)), na.rm = TRUE)
min_window_neg <- min(unlist(lapply(negBank, length)), na.rm = TRUE)
min_w <- min(min_window,min_window_neg, na.rm=TRUE)
max_w <- max(max_window,max_window_neg, na.rm=TRUE)
med_w <- round(median(min_w,max_w))
window <- c(min_w, med_w, max_w)
new_len <- max_w
}
else{
window <- windows
new_len <- max(window, na.rm = TRUE)
}
# Extending the trace so that patterns in its end can be fully screened with large
# windows :
dt <- dt[, rbind(.SD,.SD[rep(.N, max(window)),]), by = Cell_id]
# Computing steps for rolling subsequencing:
step <- as.integer(sqrt(window))* 2
# Subsequencing, Interpolation and Normalization
data <- subinoR(dt, window, step, new_len, posBank, negBank, var = Var, norm = Norm)
# DTW distance computing between each subsequence and each pattern
pos <- distcomputR(data[[2]], data[[1]], step, window)
neg <- distcomputR(data[[3]], data[[1]], step, window)
# Median distance extraction by index and Ratio between pos and neg median dist
res <- mdRatio(pos, neg)
return(res)
}
source("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Functions_Figure_Precision_Recall.R")
source("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Scripts_and_Data/Functions_Figure_Precision_Recall.R")
launchPipe <- function(data = NULL, path_to_file = "test1", rate = 1,thresh = 3, lam = 1000,
ga = 0.90, back_method = "back", roll_mean_width = 150,
rolling_pct_width = 50,pos_bank,neg_bank, windows, new_length = 30,
reference = "baseline"){
#pos_bank <- readRDS("projects/test1/pos_increased")
#neg_bank <- readRDS("projects/test1/neg_increased")
if(is.null(data)){
data <- prepareData(path_to_file, frame_rate = rate, duration_in_seconds = 30)
}
# Nouvel algo
if(back_method == "back"){
clean_data <- clean_data(data, method = "back", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10)
back_data <- patDetectR(clean_data, pos_bank, neg_bank,
Var = "Mean_Grey")
print("first back ok")
back_data_bis <- backEstimatR(clean_data,back_data)
print("entering norm")
norm_data <- norm_df(back_data_bis, var = "back", width = 10)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "background_detrended",
lambda = lam, gam = ga)
print("finishing")
}
if(back_method == "mean_10"){
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
back_data[, median_10s_before := median(.SD[time_frame %in% seq(110,120)]$Mean_Grey, na.rm = TRUE), by = Cell_id]
back_data[, mean_median := mean(.SD[time_frame %in% seq(110,120) & Mean_Grey <= median_10s_before]$Mean_Grey , na.rm = TRUE), by = Cell_id]
back_data[, gam_detrended := Mean_Grey - mean_median, by = Cell_id]
norm_data <- norm_df(back_data, var = "gam", width = 10, reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
deconvolve_data[[2]]$mean_median10 <- back_data$mean_median
}
if(back_method == "roll_mean"){
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
back_data[, rolling_mean := gplots::wapply(time_frame, Mean_Grey,fun = mean,
n = length(time_frame),  width = roll_mean_width, method = "nobs")[[2]], by = Cell_id]
back_data[, gam_detrended := Mean_Grey - rolling_mean, by = Cell_id]
norm_data <- norm_df(back_data, var = "gam", width = 10,reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
deconvolve_data[[2]]$rolling_mean <- back_data$rolling_mean
}
if(back_method == "roll_pct"){
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
back_data <- rolling_pct(back_data, rolling_pct_width, pct_lower =0.1, pct_upper =0.4, it = seq(1,2))
back_data[, gam_detrended := Mean_Grey - Mean_Grey2, by = Cell_id]
norm_data <- norm_df(back_data, var = "gam", width = 10,reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
deconvolve_data[[2]]$rolling_pct <- back_data$Mean_Grey2
}
if(back_method == "DPA") {
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
norm_data <- norm_df(back_data, var = "gam", width = 10, reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
print("finishing")
}
return(deconvolve_data)
}
ROC_pipe <- function(dt = NA, path = "C:/Users/etrives/Documents/Git/calipR/inst/extdata/test1",
frame_rate = 1, lambda = 1000, pos,neg, method ="back",
win = c(80,120,200), peak_extract_var = "background_detrended", manual,
manual_adjusted, new_length = 30, reference){
# CalipR Pipeline until deconvolution :
dt_deconvolve <- launchPipe(data = dt, path_to_file = path, rate = frame_rate, lam = lambda, pos_bank=pos,
neg_bank=neg,windows = win, back_method = method,
new_length = new_length, reference = reference)
# Peak Extraction with different thresholds
dt <- lapply(seq(0,10), function(x) peakExtraction(dt_deconvolve, thresh = x, var = peak_extract_var))
# Data preparation for comparison against manual annotation
dt <- lapply(dt, function(x) prepareROCdata(x,manual = manual,"auto_var", light = FALSE))
lapply(seq(1,length(dt)), function(x) dt[[x]][, threshold := x -1])
lapply(seq(1,length(dt)), function(x) dt[[x]][, Coverslip := 1])
dt <- do.call(rbind,dt)
# Adjusting the manual output
dt$manual_response <- manual_adjusted$manual_response
return(list(dt,dt_deconvolve))
}
library(data.table)
library(ggplot2)
library(plotly)
### Load manual annotations
manual <- setDT(get_full_df("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Scripts_and_Data/Manual_Annotation/test.sqlite", "annotations"))
manual_adjusted <- readRDS("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Scripts_and_Data/Manual_Annotation/manual_annot_adj2.RDS")
### Loading Raw data
data <- prepareData("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Scripts_and_Data/Raw_Data",
frame_rate = 1, duration_in_seconds = 30)
### Loading Raw data
data <- prepareData("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Scripts_and_Data/Raw_Data",
frame_rate = 1, duration_in_seconds = 30, unit = "minutes")
### Loading Banks
bank_list <- readRDS("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Scripts_and_Data/Banks/bank_list.RDS")
bank_list_2 <- readRDS("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Scripts_and_Data/Banks/bank_list_2.RDS")
pos_max <- readRDS("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Scripts_and_Data/Banks/pos_max")
neg_max <- readRDS("C:/Users/etrives/Documents/Git/Analyse_Performance_CalipR/Results_Precision_Recall_Papier_calipR/Scripts_and_Data/Banks/neg_max")
bank_list_3 <- c(bank_list_2,list(list(pos_max,neg_max)))
### Defining False positives
false_pos <- c("A1ame","A1aes","A1att","A1ati","A1akw","A1ars","A1att","A1atw",
"A1aro","A1art","A1apg")
### Defining noise value to extract
pct <- c(0,5,10,50)
#' @param posBank
#' @param negBank
#' @param new_len
#' @param Var
#' @param Norm
#'
#' @return A data table containing the ratio for each index and related informations
#' @export
#'
#' @examples
patDetectR <- function(dt, posBank, negBank, Var, Norm = TRUE, windows = NULL) {
print("yo")
if(is.null(windows)){
posBank<-posBank[!sapply(posBank,is.null)]
negBank<-negBank[!sapply(negBank,is.null)]
max_window <- max(unlist(lapply(posBank, length)), na.rm = TRUE)
min_window <- min(unlist(lapply(posBank, length)), na.rm = TRUE)
max_window_neg <- max(unlist(lapply(negBank, length)), na.rm = TRUE)
min_window_neg <- min(unlist(lapply(negBank, length)), na.rm = TRUE)
min_w <- min(min_window,min_window_neg, na.rm=TRUE)
max_w <- max(max_window,max_window_neg, na.rm=TRUE)
med_w <- round(median(min_w,max_w))
window <- c(min_w, med_w, max_w)
new_len <- max_w
}
else{
window <- windows
new_len <- max(window, na.rm = TRUE)
}
# Extending the trace so that patterns in its end can be fully screened with large
# windows :
dt <- dt[, rbind(.SD,.SD[rep(.N, max(window)),]), by = Cell_id]
# Computing steps for rolling subsequencing:
step <- as.integer(sqrt(window))* 2
# Subsequencing, Interpolation and Normalization
data <- subinoR(dt, window, step, new_len, posBank, negBank, var = Var, norm = Norm)
# DTW distance computing between each subsequence and each pattern
pos <- distcomputR(data[[2]], data[[1]], step, window)
neg <- distcomputR(data[[3]], data[[1]], step, window)
# Median distance extraction by index and Ratio between pos and neg median dist
res <- mdRatio(pos, neg)
return(res)
}
res_max_v1.0.0 <- ROC_pipe(dt = data,pos = pos_max, neg = neg_max, manual = manual,
win = c(80,120,200), manual_adjusted=manual_adjusted,
new_length = 30, reference = "baseline")
res_max_v1.0.0_auto_win <- ROC_pipe(dt = data,pos = pos_max, neg = neg_max, manual = manual,
manual_adjusted=manual_adjusted, reference = "baseline")
launchPipe <- function(data = NULL, path_to_file = "test1", rate = 1,thresh = 3, lam = 1000,
ga = 0.90, back_method = "back", roll_mean_width = 150,
rolling_pct_width = 50,pos_bank,neg_bank, windows, new_length = 30,
reference = "baseline"){
#pos_bank <- readRDS("projects/test1/pos_increased")
#neg_bank <- readRDS("projects/test1/neg_increased")
if(is.null(data)){
data <- prepareData(path_to_file, frame_rate = rate, duration_in_seconds = 30)
}
# Nouvel algo
if(back_method == "back"){
clean_data <- clean_data(data, method = "back", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10)
back_data <- patDetectR(clean_data, pos_bank, neg_bank,
Var = "Mean_Grey")
print("first back ok")
back_data_bis <- backEstimatR(clean_data,back_data)
print("entering norm")
norm_data <- norm_df(back_data_bis, var = "back", width = 10, reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "background_detrended",
lambda = lam, gam = ga)
print("finishing")
}
if(back_method == "mean_10"){
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
back_data[, median_10s_before := median(.SD[time_frame %in% seq(110,120)]$Mean_Grey, na.rm = TRUE), by = Cell_id]
back_data[, mean_median := mean(.SD[time_frame %in% seq(110,120) & Mean_Grey <= median_10s_before]$Mean_Grey , na.rm = TRUE), by = Cell_id]
back_data[, gam_detrended := Mean_Grey - mean_median, by = Cell_id]
norm_data <- norm_df(back_data, var = "gam", width = 10, reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
deconvolve_data[[2]]$mean_median10 <- back_data$mean_median
}
if(back_method == "roll_mean"){
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
back_data[, rolling_mean := gplots::wapply(time_frame, Mean_Grey,fun = mean,
n = length(time_frame),  width = roll_mean_width, method = "nobs")[[2]], by = Cell_id]
back_data[, gam_detrended := Mean_Grey - rolling_mean, by = Cell_id]
norm_data <- norm_df(back_data, var = "gam", width = 10,reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
deconvolve_data[[2]]$rolling_mean <- back_data$rolling_mean
}
if(back_method == "roll_pct"){
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
back_data <- rolling_pct(back_data, rolling_pct_width, pct_lower =0.1, pct_upper =0.4, it = seq(1,2))
back_data[, gam_detrended := Mean_Grey - Mean_Grey2, by = Cell_id]
norm_data <- norm_df(back_data, var = "gam", width = 10,reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
deconvolve_data[[2]]$rolling_pct <- back_data$Mean_Grey2
}
if(back_method == "DPA") {
clean_data <- clean_data(data, method = "DPA", moving_threshold = 0.1,
mean_width = 10,mean_width_diff = 10, DPA_width = 10, CN_DPA_width = 10)
back_data <- backEstimate(clean_data, method = "gam")
norm_data <- norm_df(back_data, var = "gam", width = 10, reference = reference)
print("deconvolving")
deconvolve_data <- deconvolve(norm_data, var = "gam_detrended",
lambda = lam, gam = ga)
print("finishing")
}
return(deconvolve_data)
}
res_max_v1.0.0_auto_win <- ROC_pipe(dt = data,pos = pos_max, neg = neg_max, manual = manual,
manual_adjusted=manual_adjusted, reference = "baseline")
set.seed(123)
res_robustness_max_v1.0.0_auto_win <- lapply(seq(0, 50), function(x)
precision_recall(add_weird_cells(res_max_v1.0.0_auto_win[[1]],
false_pos, x), var = 'auto_var', by = "stimulus"))
max_v1.0.0_auto_win <- extracting_data_for_plot(list(res_robustness_max_v1.0.0_auto_win),
plage = c(1:1), pct = pct, combination_increment = 15,
mean = FALSE)
max_v1.0.0_auto_win$combination <- factor(max_v1.0.0_auto_win$combination, levels = c("16"))
ggplot(data = max_v1.0.0_auto_win ,aes(x=mean_Recall,y=mean_Precision))+
geom_line(aes(group = combination,color=combination),size = 1)+
geom_point(aes(group = combination,color=combination),size = 1)+
scale_color_viridis_d(option = "D")+
facet_wrap(~percent_noise)+
ylim(c(0,1))+
xlim(c(0,1))+
theme_bw()
guigui()
data
data[.N, by = Cell_id]
data[,.N, by = Cell_id]
data[,.N, by = Cell_id][[1]]
data[,.N, by = Cell_id]
data[,.N, by = Cell_id]$N
data[,.N, by = Cell_id]$N[[1]]
215/10
round(215/10)
#'
#' @param dt
#'
#' @param patdet_out
#'
#' @return a data table with the estimated background trace in a new column called
#' "background" and the detrended Mean Grey values in a column called "background detrended"
#' @export
#'
#' @examples
backEstimatR <- function(dt, patdet_out) {
# Automatic definition of the width parameter in rolling functions (set to 1/10)
# of the length of the trace
w <- round(dt[,.N, by = Cell_id]$N[[1]] / 10)
print("w")
print(w)
patdet_out[, smooth_min_ratio := gplots::wapply(seq(1,.N), ratio,fun = min,
n = .N,  width = w, method = "nobs")[[2]], by = Cell_id]
patdet_out[, time_frame := seq(1,.N), by = Cell_id]
data.table::setkey(dt, Cell_id, time_frame)
data.table::setkey(patdet_out, Cell_id, time_frame)
full_dt <- patdet_out[dt, on = c("Cell_id", "time_frame")]
full_dt[, signal := ifelse(smooth_min_ratio > 0.95 & smooth_Diff < 2*median(smooth_Diff),
'Noise', ifelse(smooth_min_ratio < 0.95 & local_mean > median(local_mean),  'Signal', NA)), by = Cell_id]
full_dt[, rolling_min_new := gplots::wapply(time_frame, Mean_Grey,fun = function(x) quantile(x, probs = 0.2, names = FALSE),
n = length(time_frame),  width = w, method = "nobs")[[2]], by = Cell_id]
full_dt[, mean_grey_wo_peaks_new_new := ifelse(signal %in% c("Noise", NA), Mean_Grey, NA), by = Cell_id]
# If all values have been removed : fix the first and last values
full_dt[, mean_grey_wo_peaks_new_new := ifelse(time_frame %in% c(1,.N), rolling_min_new, mean_grey_wo_peaks_new_new), by = Cell_id]
# Linear interpolation between removed values
full_dt[,labels := cumsum(!is.na(mean_grey_wo_peaks_new_new)) , by = Cell_id]
full_dt[,labels2 := seq(1,.N) , by = .(Cell_id, labels)]
full_dt[,Diff := dplyr::lead(labels) - labels , by = Cell_id]
full_dt[,lag_roll_min := dplyr::lag(rolling_min_new) , by = Cell_id]
full_dt[,mean_grey_wo_peaks_new_new := ifelse(labels2 == 1 & Diff == 0,
lag_roll_min[[1]],
ifelse(labels2 == .N &
is.na(mean_grey_wo_peaks_new_new),lag_roll_min[[.N]],mean_grey_wo_peaks_new_new)),
by = .(Cell_id, labels)]
full_dt[, mean_grey_wo_peaks_new_new := ifelse(time_frame %in% c(1,.N), rolling_min_new, mean_grey_wo_peaks_new_new), by = Cell_id]
full_dt[, mean_grey_wo_peaks_new_new := approxfun(which(!is.na(mean_grey_wo_peaks_new_new)), na.omit(mean_grey_wo_peaks_new_new))(seq_along(mean_grey_wo_peaks_new_new)), by = Cell_id]
# Background estimation through a rolling median (1st round) :
full_dt[, rolling_med_new := gplots::wapply(time_frame, mean_grey_wo_peaks_new_new,fun = median,
n = length(time_frame),  width = w, method = "nobs")[[2]], by = Cell_id]
full_dt[, below_med := ifelse(mean_grey_wo_peaks_new_new < rolling_med_new, TRUE, FALSE), by = Cell_id]
# Removing values upper the rolling median :
full_dt[, mean_grey_wo_peaks_new_new := ifelse(below_med == TRUE, mean_grey_wo_peaks_new_new, NA)]
full_dt[, mean_grey_wo_peaks_new_new := ifelse(time_frame %in% c(1,.N), rolling_min_new, mean_grey_wo_peaks_new_new), by = Cell_id]
# Linear interpolation of removed values :
full_dt[, mean_grey_wo_peaks_new_new := approxfun(which(!is.na(mean_grey_wo_peaks_new_new)), na.omit(mean_grey_wo_peaks_new_new))(seq_along(mean_grey_wo_peaks_new_new)), by = Cell_id]
# Last rolling median to estimate the background
full_dt[, background := gplots::wapply(time_frame, mean_grey_wo_peaks_new_new,fun = median,
n = length(time_frame),  width = w, method = "nobs")[[2]], by = Cell_id]
full_dt[, background := ifelse(time_frame %in% c(seq(1,10),.N), Mean_Grey, background)]
full_dt[, background_detrended := Mean_Grey - background, by = .(Cell_id, coverslip)]
final_dt <- full_dt[, .(Cell_id, Mean_Grey, time_frame, time_seconds, stimulus,
coverslip,  group, Stimulation, marker_positive, local_mean,
first_derivative, smooth_Diff, signal, background, background_detrended,
Time_frame_stim
)]
return(final_dt)
}
res_max_v1.0.0_auto_win <- ROC_pipe(dt = data,pos = pos_max, neg = neg_max, manual = manual,
manual_adjusted=manual_adjusted, reference = "baseline")
set.seed(123)
res_robustness_max_v1.0.0_auto_win <- lapply(seq(0, 50), function(x)
precision_recall(add_weird_cells(res_max_v1.0.0_auto_win[[1]],
false_pos, x), var = 'auto_var', by = "stimulus"))
max_v1.0.0_auto_win <- extracting_data_for_plot(list(res_robustness_max_v1.0.0_auto_win),
plage = c(1:1), pct = pct, combination_increment = 15,
mean = FALSE)
max_v1.0.0_auto_win$combination <- factor(max_v1.0.0_auto_win$combination, levels = c("16"))
ggplot(data = max_v1.0.0_auto_win ,aes(x=mean_Recall,y=mean_Precision))+
geom_line(aes(group = combination,color=combination),size = 1)+
geom_point(aes(group = combination,color=combination),size = 1)+
scale_color_viridis_d(option = "D")+
facet_wrap(~percent_noise)+
ylim(c(0,1))+
xlim(c(0,1))+
theme_bw()
guigui()
